#owner: fankun.fan
#owner group: storage
#description: Fork Table with vector index (full/incremental index)
#tags: fork_table vector_index

--disable_warnings
drop database if exists db_fork_vec;
--enable_warnings

connect (obsys,$OBMYSQL_MS0,root@sys,,oceanbase,$OBMYSQL_PORT);
connection default;
create database db_fork_vec;
use db_fork_vec;

set ob_trx_timeout = 100000000;
set ob_query_timeout = 100000000;

alter system set ob_vector_memory_limit_percentage = 20;
sleep 3;

#########################################################################
--echo # 1. Fork table with existing HNSW vector index
#########################################################################

--disable_warnings
drop table if exists t_src;
drop table if exists t_fork;
--enable_warnings

create table t_src(c1 int, c2 vector(3), primary key(c1), vector index idx1(c2) with (distance=l2, type=hnsw, lib=vsag, m=16, ef_construction=200));

insert into t_src values(1, '[0.203846,0.205289,0.880265]');
insert into t_src values(2, '[0.484526,0.669954,0.986755]');
insert into t_src values(3, '[0.327936,0.048756,0.084670]');
insert into t_src values(4, '[0.148869,0.878546,0.028024]');
insert into t_src values(5, '[0.334970,0.857377,0.886132]');

--echo # Fork table
fork table t_src to t_fork;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Vector query on fork table (approx vs exact)
select * from t_fork order by l2_distance(c2, [0.2,0.2,0.5]) APPROXIMATE limit 3;
select * from t_fork order by l2_distance(c2, [0.2,0.2,0.5]) limit 3;
select count(*) from (select * from t_fork order by l2_distance(c2, [0.2,0.2,0.5]) APPROXIMATE limit 3) as tmp1, (select * from t_fork order by l2_distance(c2, [0.2,0.2,0.5]) limit 3) as tmp2 where tmp1.c1=tmp2.c1;

drop table t_src;
drop table t_fork;

#########################################################################
--echo # 2. Fork source table with incr/snap/mixed vector index data
#########################################################################

--disable_warnings
drop table if exists t_src2;
drop table if exists t_fork_incr;
drop table if exists t_fork_snap;
drop table if exists t_fork_mixed;
--enable_warnings

--echo # Create source table with vector index
create table t_src2(c1 int, c2 vector(3), primary key(c1), vector index idx1(c2) with (distance=l2, type=hnsw, lib=vsag, m=16, ef_construction=200, ef_search=200));

--echo # Insert data into source table (data goes to incremental index)
insert into t_src2 values(1, '[0.1,0.1,0.1]');
insert into t_src2 values(2, '[0.203846,0.205289,0.880265]');
insert into t_src2 values(3, '[0.484526,0.669954,0.986755]');
insert into t_src2 values(4, '[0.327936,0.048756,0.084670]');
insert into t_src2 values(5, '[0.148869,0.878546,0.028024]');

--sleep 5

--echo # Fork source table when data is in incremental index
fork table t_src2 to t_fork_incr;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Vector query on fork table with incremental data
select * from t_fork_incr order by l2_distance(c2, [0.1,0.1,0.1]) APPROXIMATE limit 3;
select * from t_fork_incr order by l2_distance(c2, [0.1,0.1,0.1]) limit 3;
select count(*) from (select * from t_fork_incr order by l2_distance(c2, [0.1,0.1,0.1]) APPROXIMATE limit 3) as tmp1, (select * from t_fork_incr order by l2_distance(c2, [0.1,0.1,0.1]) limit 3) as tmp2 where tmp1.c1=tmp2.c1;

--echo # Rebuild source table vector index (data moves to snapshot/full index)
call dbms_vector.rebuild_index('idx1','t_src2','c2');

--sleep 10

--echo # Fork source table when data is in snapshot index
fork table t_src2 to t_fork_snap;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Vector query on fork table with snapshot data
select * from t_fork_snap order by l2_distance(c2, [0.1,0.1,0.1]) APPROXIMATE limit 3;
select * from t_fork_snap order by l2_distance(c2, [0.1,0.1,0.1]) limit 3;
select count(*) from (select * from t_fork_snap order by l2_distance(c2, [0.1,0.1,0.1]) APPROXIMATE limit 3) as tmp1, (select * from t_fork_snap order by l2_distance(c2, [0.1,0.1,0.1]) limit 3) as tmp2 where tmp1.c1=tmp2.c1;

--echo # Insert more data into source table after rebuild (mixed: snap + incr)
insert into t_src2 values(10, '[0.0,0.0,0.0]');
insert into t_src2 values(11, '[0.999,0.999,0.999]');

--sleep 5

--echo # Fork source table when data is mixed (snap + incr)
fork table t_src2 to t_fork_mixed;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Vector query on fork table with mixed data
select * from t_fork_mixed order by l2_distance(c2, [0.0,0.0,0.0]) APPROXIMATE limit 3;
select * from t_fork_mixed order by l2_distance(c2, [0.0,0.0,0.0]) limit 3;
select count(*) from (select * from t_fork_mixed order by l2_distance(c2, [0.0,0.0,0.0]) APPROXIMATE limit 3) as tmp1, (select * from t_fork_mixed order by l2_distance(c2, [0.0,0.0,0.0]) limit 3) as tmp2 where tmp1.c1=tmp2.c1;

drop table t_src2;
drop table t_fork_incr;
drop table t_fork_snap;
drop table t_fork_mixed;

#########################################################################
--echo # 3. COW isolation: source DML/rebuild does not affect fork table
#########################################################################

--disable_warnings
drop table if exists t_src3;
drop table if exists t_fork3;
--enable_warnings

create table t_src3(c1 int, c2 vector(3), primary key(c1), vector index idx1(c2) with (distance=l2, type=hnsw, lib=vsag));
insert into t_src3 values(1, '[1,1,1]');
insert into t_src3 values(2, '[2,2,2]');
insert into t_src3 values(3, '[3,3,3]');

fork table t_src3 to t_fork3;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Record fork table data before source modification
select * from t_fork3 order by c1;

--echo # Modify source table: update/delete/insert
update t_src3 set c2 = '[100,100,100]' where c1 = 1;
delete from t_src3 where c1 = 2;
insert into t_src3 values(100, '[0,0,0]');

--echo # Rebuild source table vector index
call dbms_vector.rebuild_index('idx1','t_src3','c2');

--echo # Verify fork table unchanged (COW isolation)
select * from t_fork3 order by c1;
select * from t_fork3 order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;

--echo # Verify source table changed
select * from t_src3 order by c1;

drop table t_src3;
drop table t_fork3;

#########################################################################
--echo # 4. Fork table and source table DML isolation
#########################################################################

--disable_warnings
drop table if exists t_src4;
drop table if exists t_fork4;
--enable_warnings

create table t_src4(c1 int, c2 vector(3), primary key(c1), vector index idx1(c2) with (distance=l2, type=hnsw, lib=vsag));
insert into t_src4 values(1, '[1,1,1]');
insert into t_src4 values(2, '[2,2,2]');
insert into t_src4 values(3, '[3,3,3]');

fork table t_src4 to t_fork4;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # DML on fork table
update t_fork4 set c2 = '[0.1,0.1,0.1]' where c1 = 1;
delete from t_fork4 where c1 = 2;
insert into t_fork4 values(100, '[0,0,0]');

--echo # DML on source table (different modifications)
update t_src4 set c2 = '[99,99,99]' where c1 = 1;
delete from t_src4 where c1 = 3;
insert into t_src4 values(200, '[50,50,50]');

--echo # Verify fork table has its own modifications
select * from t_fork4 order by c1;
select * from t_fork4 order by l2_distance(c2, [0,0,0]) limit 3;

--echo # Verify source table has its own modifications
select * from t_src4 order by c1;
select * from t_src4 order by l2_distance(c2, [0,0,0]) limit 3;

--echo # Rebuild both tables and verify isolation
call dbms_vector.rebuild_index('idx1','t_fork4','c2');
call dbms_vector.rebuild_index('idx1','t_src4','c2');

select * from t_fork4 order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;
select * from t_src4 order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;

drop table t_src4;
drop table t_fork4;

#########################################################################
--echo # 5. Drop source table, fork table still works
#########################################################################

--disable_warnings
drop table if exists t_src5;
drop table if exists t_fork5;
--enable_warnings

create table t_src5(c1 int, c2 vector(3), primary key(c1), vector index idx1(c2) with (distance=l2, type=hnsw, lib=vsag));
insert into t_src5 values(1, '[1,1,1]');
insert into t_src5 values(2, '[2,2,2]');
insert into t_src5 values(3, '[3,3,3]');

fork table t_src5 to t_fork5;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Drop source table
drop table t_src5;

--echo # Fork table still works after source dropped
select * from t_fork5 order by c1;
select * from t_fork5 order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;
select * from t_fork5 order by l2_distance(c2, [0,0,0]) limit 3;

--echo # DML on fork table still works
insert into t_fork5 values(10, '[0,0,0]');
update t_fork5 set c2 = '[0.5,0.5,0.5]' where c1 = 1;
delete from t_fork5 where c1 = 3;

select * from t_fork5 order by l2_distance(c2, [0,0,0]) limit 3;

--echo # Rebuild fork table vector index still works
call dbms_vector.rebuild_index('idx1','t_fork5','c2');
select * from t_fork5 order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;

drop table t_fork5;

#########################################################################
--echo # 6. Multi-level fork (fork of fork) with vector index
#########################################################################

--disable_warnings
drop table if exists t_src6;
drop table if exists t_fork6_l1;
drop table if exists t_fork6_l2;
--enable_warnings

create table t_src6(c1 int, c2 vector(3), primary key(c1), vector index idx1(c2) with (distance=l2, type=hnsw, lib=vsag));
insert into t_src6 values(1, '[1,1,1]');
insert into t_src6 values(2, '[2,2,2]');
insert into t_src6 values(3, '[3,3,3]');

--echo # First level fork
fork table t_src6 to t_fork6_l1;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Modify first level fork
insert into t_fork6_l1 values(10, '[0,0,0]');

--echo # Second level fork (fork of fork)
fork table t_fork6_l1 to t_fork6_l2;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Verify all three tables have correct data
select * from t_src6 order by c1;
select * from t_fork6_l1 order by c1;
select * from t_fork6_l2 order by c1;

--echo # Vector query on all three tables
select * from t_src6 order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;
select * from t_fork6_l1 order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;
select * from t_fork6_l2 order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;

--echo # Modify second level fork independently
insert into t_fork6_l2 values(20, '[0.1,0.1,0.1]');
update t_fork6_l2 set c2 = '[0.5,0.5,0.5]' where c1 = 1;

--echo # Verify isolation between all levels
select * from t_src6 order by c1;
select * from t_fork6_l1 order by c1;
select * from t_fork6_l2 order by c1;

drop table t_src6;
drop table t_fork6_l1;
drop table t_fork6_l2;

--disable_parsing
# TODO(fankun.fan): fiexd later

#########################################################################
--echo # 7. Fork table with IVF vector index
#########################################################################

--disable_warnings
drop table if exists t_src_ivf;
drop table if exists t_fork_ivf;
--enable_warnings

create table t_src_ivf(c1 int, c2 vector(3), primary key(c1), vector index idx1(c2) with (distance=l2, type=ivf_flat));

insert into t_src_ivf values(1, '[1,1,1]');
insert into t_src_ivf values(2, '[2,2,2]');
insert into t_src_ivf values(3, '[3,3,3]');
insert into t_src_ivf values(4, '[4,4,4]');
insert into t_src_ivf values(5, '[5,5,5]');

--echo # Fork table with IVF index
fork table t_src_ivf to t_fork_ivf;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Vector query on fork table with IVF index
select * from t_fork_ivf order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;
select * from t_fork_ivf order by l2_distance(c2, [0,0,0]) limit 3;

--echo # DML on fork table with IVF index
update t_fork_ivf set c2 = '[0.5,0.5,0.5]' where c1 = 1;
insert into t_fork_ivf values(10, '[0,0,0]');
delete from t_fork_ivf where c1 = 5;

--echo # Vector query after DML
select * from t_fork_ivf order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;
select * from t_fork_ivf order by l2_distance(c2, [0,0,0]) limit 3;

--echo # Verify source table unchanged
select * from t_src_ivf order by c1;

drop table t_src_ivf;
drop table t_fork_ivf;

#########################################################################
--echo # 8. Fork source IVF table with incr/snap data
#########################################################################

--disable_warnings
drop table if exists t_src_ivf2;
drop table if exists t_fork_ivf_incr;
drop table if exists t_fork_ivf_snap;
--enable_warnings

create table t_src_ivf2(c1 int, c2 vector(3), primary key(c1), vector index idx1(c2) with (distance=l2, type=ivf_flat));

--echo # Insert data (IVF incremental)
insert into t_src_ivf2 values(1, '[1,1,1]');
insert into t_src_ivf2 values(2, '[2,2,2]');
insert into t_src_ivf2 values(3, '[3,3,3]');

--echo # Fork when data is fresh (IVF delta)
fork table t_src_ivf2 to t_fork_ivf_incr;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Vector query on incr fork
select * from t_fork_ivf_incr order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;

--echo # Rebuild source IVF index
call dbms_vector.rebuild_index('idx1','t_src_ivf2','c2');

--echo # Verify source table works after rebuild
select * from t_src_ivf2 order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;

--echo # Fork after rebuild
fork table t_src_ivf2 to t_fork_ivf_snap;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Vector query on snap fork (exact query first)
select * from t_fork_ivf_snap order by l2_distance(c2, [0,0,0]) limit 3;

--echo # Vector query on snap fork (approximate query)
select * from t_fork_ivf_snap order by l2_distance(c2, [0,0,0]) APPROXIMATE limit 3;

--echo # Both forks have same data
select count(*) from t_fork_ivf_incr;
select count(*) from t_fork_ivf_snap;

drop table t_src_ivf2;
drop table t_fork_ivf_incr;
drop table t_fork_ivf_snap;

--enable_parsing

#########################################################################
--echo # 9. Cleanup
#########################################################################

--disable_warnings
drop database if exists db_fork_vec;
--enable_warnings

alter system set ob_vector_memory_limit_percentage = 0;
