##owner: fankun.fan
##owner group: 底层引擎部-轻量版
##description: Fork Table多SSTable场景测试
##tags: fork_table sstable
##author: fankun.fan

--disable_warnings
drop database if exists db_fork_sstable;
--enable_warnings

connect (obsys,$OBMYSQL_MS0,root@sys,,oceanbase,$OBMYSQL_PORT);
connection default;
create database db_fork_sstable;
use db_fork_sstable;

SET wait_timeout=30000000;
SET ob_trx_timeout = 100000000;
SET ob_query_timeout = 100000000;

--echo # 启用debug sync
connection obsys;
alter system set debug_sync_timeout = '120s';
sleep 1;
set ob_global_debug_sync = 'reset';
connection default;

--echo # 加速major freeze
--source mysql_test/test_suite/fork_table/include/quick_major.inc

--echo ============================================
--echo Case 1: Fork表与混合SSTable（Major + Minor + Memtable）
--echo ============================================

drop table if exists t1;
drop table if exists t1_fork;

create table t1 (
    id int primary key,
    name varchar(50),
    value int,
    large_data text
) partition by range(id) (
    partition p0 values less than (100),
    partition p1 values less than (200)
);

--echo # Step 1: 插入数据并触发major freeze（产生Major SSTable）
insert into t1 values (1, 'Major_P0_1', 100, repeat('A', 500));
insert into t1 values (101, 'Major_P1_1', 200, repeat('B', 500));
alter system major freeze;
--source mysql_test/test_suite/fork_table/include/wait_daily_merge.inc

--echo # Step 2: 插入数据并触发minor freeze（产生Minor SSTable）
insert into t1 values (2, 'Minor_P0_1', 300, repeat('C', 500));
insert into t1 values (102, 'Minor_P1_1', 400, repeat('D', 500));
alter system minor freeze;
--source mysql_test/include/wait_minor_merge.inc

--echo # Step 3: 插入数据到Memtable（未冻结）
insert into t1 values (3, 'Memtable_P0_1', 500, repeat('E', 500));
insert into t1 values (103, 'Memtable_P1_1', 600, repeat('F', 500));

--echo # Step 4: Fork表
fork table t1 to t1_fork;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # 验证Fork表数据完整性
select count(*) as src_cnt from t1;
select count(*) as fork_cnt from t1_fork;

select id, name, value, length(large_data) as data_len from t1 order by id;
select id, name, value, length(large_data) as data_len from t1_fork order by id;

--echo # 验证COW：同时在源表和Fork表插入新数据
insert into t1 values (4, 'NewData_Src', 700, repeat('G', 500));
insert into t1_fork values (5, 'NewData_Fork', 800, repeat('H', 500));
select count(*) as src_cnt from t1;
select count(*) as fork_cnt from t1_fork;

--echo # 验证COW：同时在源表和Fork表修改数据
update t1 set large_data = repeat('X', 1000) where id = 1;
update t1_fork set large_data = repeat('Z', 1000) where id = 1;
select id, name, length(large_data) as data_len, substring(large_data, 1, 10) as preview from t1 where id = 1;
select id, name, length(large_data) as data_len, substring(large_data, 1, 10) as preview from t1_fork where id = 1;

--echo # 验证数据隔离：源表和Fork表各自独立
select id, name, value from t1 order by id;
select id, name, value from t1_fork order by id;

--echo ============================================
--echo Case 2: Fork过程中（BUILD_DATA阶段）执行混合SSTable操作
--echo ============================================

drop table if exists t2;
drop table if exists t2_fork;

create table t2 (
    id int primary key,
    name varchar(50),
    value int,
    large_data text
) partition by range(id) (
    partition p0 values less than (100),
    partition p1 values less than (200)
);

--echo # 准备初始数据
insert into t2 values (1, 'Init_P0_1', 100, repeat('A', 500));
insert into t2 values (101, 'Init_P1_1', 200, repeat('B', 500));

--echo # 设置debug sync point在FORK_TABLE_BUILD_DATA阶段暂停
connection obsys;
set ob_global_debug_sync = 'FORK_TABLE_BUILD_DATA wait_for build_data_signal execute 10000';
sleep 1;
connection default;

--echo # 执行Fork命令（会在BUILD_DATA阶段暂停）
fork table t2 to t2_fork;

--echo # 在BUILD_DATA阶段同时对源表和Fork表执行混合SSTable操作
--echo # Step 1: 同时在源表和Fork表插入数据并触发major freeze
insert into t2 values (2, 'Major_P0_1', 300, repeat('C', 500));
insert into t2 values (102, 'Major_P1_1', 400, repeat('D', 500));
insert into t2_fork values (10, 'Fork_Major_P0', 1000, repeat('M', 500));
alter system major freeze;

--echo # Step 2: 同时在源表和Fork表插入数据并触发minor freeze
insert into t2 values (3, 'Minor_P0_1', 500, repeat('E', 500));
insert into t2 values (103, 'Minor_P1_1', 600, repeat('F', 500));
insert into t2_fork values (11, 'Fork_Minor_P0', 1100, repeat('N', 500));
alter system minor freeze;
--source mysql_test/include/wait_minor_merge.inc

--echo # Step 3: 同时在源表和Fork表插入Memtable数据
insert into t2 values (4, 'Memtable_P0_1', 700, repeat('G', 500));
insert into t2 values (104, 'Memtable_P1_1', 800, repeat('H', 500));
insert into t2_fork values (12, 'Fork_Mem_P0', 1200, repeat('O', 500));

--echo # Step 4: 同时更新源表和Fork表已有数据
update t2 set value = 999 where id = 1;
update t2_fork set value = 888 where id = 1;

--echo # 继续Fork执行
connection obsys;
set ob_global_debug_sync = 'FORK_TABLE_BUILD_DATA clear';
set ob_global_debug_sync = 'now signal build_data_signal';
connection default;

--echo # 等待Fork和合并完成
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc
--source mysql_test/test_suite/fork_table/include/wait_daily_merge.inc

--echo # 验证源表和Fork表数据
select count(*) as src_cnt from t2;
select count(*) as fork_cnt from t2_fork;

select id, name, value from t2 order by id;
select id, name, value from t2_fork order by id;

--echo # 验证COW：继续在两个表上操作
update t2_fork set value = 7777 where id = 1;
update t2 set value = 6666 where id = 1;
select id, value from t2 where id = 1;
select id, value from t2_fork where id = 1;

--echo ============================================
--echo Case 3: Snapshot保护测试（undo_retention=0时SSTable不被回收）
--echo ============================================

drop table if exists t3;
drop table if exists t3_fork;

--echo # 设置undo_retention=0（核心前置条件）
--echo # undo_retention=0意味着系统不保留旧版本数据
--echo # 如果没有snapshot保护，compaction时旧SSTable会被回收
connection obsys;
alter system set undo_retention = 0;
sleep 1;
connection default;

create table t3 (
    id int primary key,
    name varchar(50),
    value int,
    large_data text
) partition by range(id) (
    partition p0 values less than (100),
    partition p1 values less than (200)
);

--echo # 构建混合SSTable
insert into t3 values (1, 'Major_P0', 100, repeat('A', 500));
insert into t3 values (101, 'Major_P1', 200, repeat('B', 500));
alter system major freeze;
--source mysql_test/test_suite/fork_table/include/wait_daily_merge.inc

insert into t3 values (2, 'Minor_P0', 300, repeat('C', 500));
insert into t3 values (102, 'Minor_P1', 400, repeat('D', 500));
alter system minor freeze;
--source mysql_test/include/wait_minor_merge.inc

insert into t3 values (3, 'Memtable_P0', 500, repeat('E', 500));
insert into t3 values (103, 'Memtable_P1', 600, repeat('F', 500));

--echo # 记录Fork前数据
select count(*) as pre_fork_count from t3;

--echo # 使用debug sync在BUILD_DATA阶段暂停Fork
connection obsys;
set ob_global_debug_sync = 'FORK_TABLE_BUILD_DATA wait_for snapshot_signal execute 10000';
sleep 1;
connection default;

--echo # 执行Fork命令（会在BUILD_DATA阶段暂停）
fork table t3 to t3_fork;

--echo # 在Fork暂停期间同时对源表和Fork表操作，并触发Major Freeze
--echo # 如果没有snapshot保护，旧SSTable可能被回收导致数据丢失
insert into t3 values (4, 'NewData_Src', 700, repeat('G', 500));
insert into t3_fork values (5, 'NewData_Fork', 800, repeat('H', 500));
update t3 set value = 111 where id = 1;
update t3_fork set value = 222 where id = 1;
#alter system minor freeze;
#--source mysql_test/include/wait_minor_merge.inc

--echo # 继续Fork执行
connection obsys;
set ob_global_debug_sync = 'FORK_TABLE_BUILD_DATA clear';
set ob_global_debug_sync = 'now signal snapshot_signal';
connection default;

--echo # 等待Fork完成
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc
--source mysql_test/test_suite/fork_table/include/wait_daily_merge.inc


--echo # 验证Snapshot保护生效 - 数据完整
select count(*) as src_cnt from t3;
select count(*) as fork_cnt from t3_fork;

select id, name, value, length(large_data) as data_len from t3 order by id;
select id, name, value, length(large_data) as data_len from t3_fork order by id;

--echo # 验证COW正常工作：继续同时操作两个表
update t3 set value = 3333 where id = 1;
update t3_fork set value = 4444 where id = 1;
insert into t3 values (6, 'Final_Src', 900, repeat('I', 500));
insert into t3_fork values (7, 'Final_Fork', 1000, repeat('J', 500));
select id, value from t3 where id in (1, 6) order by id;
select id, value from t3_fork where id in (1, 7) order by id;

--echo # 恢复undo_retention到默认值
connection obsys;
alter system set undo_retention = 1800;
connection default;

--echo ============================================
--echo Case 4: column_info_simplified场景触发fork
--echo ============================================

--disable_warnings
drop table if exists t4;
drop table if exists t4_fork;
--enable_warnings

create table t4 (
    id int primary key,
    c1 int
) partition by range(id) (
    partition p0 values less than (100),
    partition p1 values less than (200)
);

--echo # Step 1: 先生成major sstable（旧schema）
insert into t4 values (1, 10);
insert into t4 values (101, 20);
connection obsys;
alter system major freeze;
--source mysql_test/test_suite/fork_table/include/wait_daily_merge.inc
connection default;

--echo # Step 2: 增加列并写入新列数据，触发schema差异
alter table t4 add column c2 int default 0;
insert into t4(id, c1, c2) values (2, 30, 300);
insert into t4(id, c1, c2) values (102, 40, 400);

--echo # Step 3: minor freeze，让新列进入存储层
connection obsys;
alter system minor freeze;
--source mysql_test/include/wait_minor_merge.inc
connection default;

--echo # Step 4: fork table（若存在column_info_simplified问题，此处会失败或卡住）
fork table t4 to t4_fork;
--source mysql_test/test_suite/fork_table/include/wait_fork_table.inc

--echo # Step 5: 基础校验
select count(*) as src_cnt from t4;
select count(*) as fork_cnt from t4_fork;

--echo ============================================
--echo 清理
--echo ============================================

--echo # 重置debug sync
connection obsys;
set ob_global_debug_sync = 'reset';
connection default;

drop table if exists t1;
drop table if exists t1_fork;
drop table if exists t2;
drop table if exists t2_fork;
drop table if exists t3;
drop table if exists t3_fork;
drop table if exists t4;
drop table if exists t4_fork;
drop database if exists db_fork_sstable;
