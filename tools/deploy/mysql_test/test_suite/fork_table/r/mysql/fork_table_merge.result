drop database if exists db_fork_major;
create database db_fork_major;
use db_fork_major;
SET wait_timeout=30000000;
SET ob_trx_timeout = 100000000;
SET ob_query_timeout = 100000000;
# 启用debug sync
alter system set debug_sync_timeout = '60s';
set ob_global_debug_sync = 'reset';
# 加速major freeze
alter system set merger_check_interval = '10s' tenant sys;
alter system set ob_compaction_schedule_interval = '3s' tenant sys;
============================================
1. Fork在BUILD_DATA阶段触发major merge
============================================
drop table if exists t1;
Warnings:
Note	1051	Unknown table 'db_fork_major.t1'
drop table if exists t1_fork;
Warnings:
Note	1051	Unknown table 'db_fork_major.t1_fork'
create table t1 (
id int primary key,
name varchar(50),
value int
) partition by range(id) (
partition p0 values less than (100),
partition p1 values less than (200)
);
insert into t1 values (1, 'Init1', 100);
insert into t1 values (101, 'Init2', 200);
# 设置debug sync信号，让fork卡在BUILD_DATA阶段
set ob_global_debug_sync = 'FORK_TABLE_BUILD_DATA wait_for fork_major_signal execute 10000';
# 执行fork命令（会在BUILD_DATA阶段暂停）
fork table t1 to t1_fork;
# 等待fork进入BUILD_DATA阶段
# 在BUILD_DATA阶段向源表插入数据
insert into t1 values (50, 'After_Fork', 300);
insert into t1 values (150, 'After_Fork2', 400);
# 触发major merge（不等待完成）
alter system major freeze;
# 校验源表tablet级major merge完成（fork仍停在BUILD_DATA）
# 继续fork执行
set ob_global_debug_sync = 'FORK_TABLE_BUILD_DATA clear';
set ob_global_debug_sync = 'now signal fork_major_signal';
# 等待fork任务完成
# 验证fork表快照数据
select count(*) as cnt from t1_fork;
cnt
2
select * from t1_fork order by id;
id	name	value
1	Init1	100
101	Init2	200
# 验证源表包含最新数据
select count(*) as cnt from t1;
cnt
4
select * from t1 order by id;
id	name	value
1	Init1	100
50	After_Fork	300
101	Init2	200
150	After_Fork2	400
============================================
2. 清理
============================================
drop table if exists t1;
drop table if exists t1_fork;
drop database if exists db_fork_major;
set ob_global_debug_sync = 'reset';
