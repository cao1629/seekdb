drop database if exists db_fork_basic;
create database db_fork_basic;
use db_fork_basic;
SET wait_timeout=30000000;
SET ob_trx_timeout = 100000000;
SET ob_query_timeout = 100000000;
============================================
1. 基本Fork Table功能测试
============================================
drop table if exists t1;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t1'
drop table if exists t1_fork;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t1_fork'
# 创建源表并插入数据
create table t1 (
id int primary key,
name varchar(50),
age int,
status int default 0
) partition by range(id) (
partition p0 values less than (100),
partition p1 values less than (200),
partition p2 values less than (300)
);
insert into t1 values (1, 'Alice', 25, 1);
insert into t1 values (101, 'Bob', 30, 1);
insert into t1 values (201, 'Charlie', 35, 1);
insert into t1 values (50, 'David', 28, 1);
insert into t1 values (150, 'Eve', 32, 1);
# 执行Fork Table
fork table t1 to t1_fork;
# 验证Fork后的表结构
show create table t1_fork;
Table	Create Table
t1_fork	CREATE TABLE `t1_fork` (
  `id` int(11) NOT NULL,
  `name` varchar(50) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `status` int(11) DEFAULT '0',
  PRIMARY KEY (`id`)
) ORGANIZATION INDEX DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = replica_num BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE ENABLE_MACRO_BLOCK_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0
 partition by range(id)
(partition `p0` values less than (100),
partition `p1` values less than (200),
partition `p2` values less than (300))
# 验证Fork后的数据
select count(*) as cnt from t1_fork;
cnt
5
select * from t1_fork order by id;
id	name	age	status
1	Alice	25	1
50	David	28	1
101	Bob	30	1
150	Eve	32	1
201	Charlie	35	1
# 验证源表数据未受影响
select count(*) as cnt from t1;
cnt
5
select * from t1 order by id;
id	name	age	status
1	Alice	25	1
50	David	28	1
101	Bob	30	1
150	Eve	32	1
201	Charlie	35	1
============================================
2. 数据隔离测试 - Fork表修改不影响源表
============================================
# 在Fork表中插入新数据
insert into t1_fork values (99, 'Fork_New', 40, 1);
insert into t1_fork values (299, 'Fork_New2', 45, 1);
# 验证Fork表有新数据
select count(*) as cnt from t1_fork;
cnt
7
select * from t1_fork where id in (99, 299);
id	name	age	status
99	Fork_New	40	1
299	Fork_New2	45	1
# 验证源表数据未受影响
select count(*) as cnt from t1;
cnt
5
select * from t1 where id in (99, 299);
id	name	age	status
# 在源表中插入新数据
insert into t1 values (88, 'Source_New', 50, 1);
insert into t1 values (288, 'Source_New2', 55, 1);
# 验证源表有新数据
select count(*) as cnt from t1;
cnt
7
select * from t1 where id in (88, 288);
id	name	age	status
88	Source_New	50	1
288	Source_New2	55	1
# 验证Fork表数据未受影响
select count(*) as cnt from t1_fork;
cnt
7
select * from t1_fork where id in (88, 288);
id	name	age	status
============================================
3. 数据修改隔离测试
============================================
# 修改Fork表中的数据
update t1_fork set name = 'Fork_Updated', age = 100 where id = 1;
update t1_fork set name = 'Fork_Updated2', age = 200 where id = 101;
# 验证Fork表数据已修改
select * from t1_fork where id in (1, 101);
id	name	age	status
1	Fork_Updated	100	1
101	Fork_Updated2	200	1
# 验证源表数据未受影响
select * from t1 where id in (1, 101);
id	name	age	status
1	Alice	25	1
101	Bob	30	1
# 修改源表中的数据
update t1 set name = 'Source_Updated', age = 300 where id = 201;
update t1 set name = 'Source_Updated2', age = 400 where id = 50;
# 验证源表数据已修改
select * from t1 where id in (201, 50);
id	name	age	status
50	Source_Updated2	400	1
201	Source_Updated	300	1
# 验证Fork表数据未受影响
select * from t1_fork where id in (201, 50);
id	name	age	status
50	David	28	1
201	Charlie	35	1
============================================
4. 删除数据隔离测试
============================================
# 从Fork表中删除数据
delete from t1_fork where id = 50;
# 验证Fork表数据已删除
select count(*) as cnt from t1_fork;
cnt
6
select * from t1_fork where id = 50;
id	name	age	status
# 验证源表数据未受影响
select count(*) as cnt from t1;
cnt
7
select * from t1 where id = 50;
id	name	age	status
50	Source_Updated2	400	1
# 从源表中删除数据
delete from t1 where id = 150;
# 验证源表数据已删除
select count(*) as cnt from t1;
cnt
6
select * from t1 where id = 150;
id	name	age	status
# 验证Fork表数据未受影响
select count(*) as cnt from t1_fork;
cnt
6
select * from t1_fork where id = 150;
id	name	age	status
150	Eve	32	1
============================================
5. 空表Fork测试
============================================
drop table if exists t2;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t2'
drop table if exists t2_fork;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t2_fork'
create table t2 (
id int primary key,
name varchar(50)
);
# Fork空表
fork table t2 to t2_fork;
# 验证Fork表结构
show create table t2_fork;
Table	Create Table
t2_fork	CREATE TABLE `t2_fork` (
  `id` int(11) NOT NULL,
  `name` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ORGANIZATION INDEX DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = replica_num BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE ENABLE_MACRO_BLOCK_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0
# 验证Fork表为空
select count(*) as cnt from t2_fork;
cnt
0
# 在Fork表中插入数据
insert into t2_fork values (1, 'Fork_Data');
# 验证Fork表有新数据
select * from t2_fork;
id	name
1	Fork_Data
# 验证源表仍为空
select count(*) as cnt from t2;
cnt
0
============================================
6. Fork带自增列的表
============================================
drop table if exists t3;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t3'
drop table if exists t3_fork;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t3_fork'
create table t3 (
id int auto_increment primary key,
name varchar(50),
value int
) partition by range(id) (
partition p0 values less than (100),
partition p1 values less than (200)
);
insert into t3(name, value) values ('Alice', 100);
insert into t3(name, value) values ('Bob', 200);
insert into t3(name, value) values ('Charlie', 300);
# Fork表
fork table t3 to t3_fork;
# 验证Fork表数据
select * from t3_fork order by id;
id	name	value
1	Alice	100
2	Bob	200
3	Charlie	300
# 在Fork表中插入数据，验证自增列从正确位置开始
insert into t3_fork(name, value) values ('Fork_Test', 999);
select * from t3_fork order by id;
id	name	value
1	Alice	100
2	Bob	200
3	Charlie	300
4	Fork_Test	999
============================================
7. Fork表自增列隔离测试
============================================
# 在源表中插入数据
insert into t3(name, value) values ('Source_New', 400);
select * from t3 order by id;
id	name	value
1	Alice	100
2	Bob	200
3	Charlie	300
4	Source_New	400
# 在Fork表中插入数据，验证自增列独立工作
insert into t3_fork(name, value) values ('Fork_New', 500);
select * from t3_fork order by id;
id	name	value
1	Alice	100
2	Bob	200
3	Charlie	300
4	Fork_Test	999
5	Fork_New	500
# 再次在源表和Fork表中插入数据，验证自增列继续独立递增
insert into t3(name, value) values ('Source_New2', 600);
insert into t3_fork(name, value) values ('Fork_New2', 700);
select * from t3 order by id;
id	name	value
1	Alice	100
2	Bob	200
3	Charlie	300
4	Source_New	400
5	Source_New2	600
select * from t3_fork order by id;
id	name	value
1	Alice	100
2	Bob	200
3	Charlie	300
4	Fork_Test	999
5	Fork_New	500
6	Fork_New2	700
============================================
8. Fork表自增列手动设置
============================================
drop table if exists t4;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t4'
drop table if exists t4_fork;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t4_fork'
create table t4 (
id int auto_increment primary key,
name varchar(50)
);
insert into t4(name) values ('Data1');
insert into t4(name) values ('Data2');
# 手动设置自增值
alter table t4 auto_increment = 100;
# Fork表
fork table t4 to t4_fork;
# 在Fork表中插入数据，验证自增列从手动设置的值开始
insert into t4_fork(name) values ('Fork_Data');
select * from t4_fork order by id;
id	name
1	Data1
2	Data2
100	Fork_Data
# 继续插入，验证自增列递增
insert into t4_fork(name) values ('Fork_Data2');
select * from t4_fork order by id;
id	name
1	Data1
2	Data2
100	Fork_Data
101	Fork_Data2
============================================
9. Fork表自增列与分区
============================================
drop table if exists t5;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t5'
drop table if exists t5_fork;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t5_fork'
create table t5 (
id int auto_increment,
name varchar(50),
primary key(id, name)
) partition by hash(id) partitions 2;
insert into t5(name) values ('Data1');
insert into t5(name) values ('Data2');
insert into t5(name) values ('Data3');
# Fork表
fork table t5 to t5_fork;
# 先验证原表各分区数据
select * from t5 order by id, name;
id	name
1	Data1
2	Data2
3	Data3
# 验证Fork表各分区数据
select * from t5_fork order by id, name;
id	name
1	Data1
2	Data2
3	Data3
# 先在原表插入数据，验证原表自增列
insert into t5(name) values ('Source_Data');
select * from t5 order by id, name;
id	name
1	Data1
2	Data2
3	Data3
4	Source_Data
# 在Fork表插入数据，验证自增列独立工作
insert into t5_fork(name) values ('Fork_Data');
select * from t5_fork order by id, name;
id	name
1	Data1
2	Data2
3	Data3
4	Fork_Data
============================================
6. 清理
============================================
drop table if exists t1;
drop table if exists t1_fork;
drop table if exists t2;
drop table if exists t2_fork;
drop table if exists t3;
drop table if exists t3_fork;
drop table if exists t4;
drop table if exists t4_fork;
drop table if exists t5;
drop table if exists t5_fork;
drop table if exists t_trunc;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t_trunc'
drop table if exists t_trunc_fork;
Warnings:
Note	1051	Unknown table 'db_fork_basic.t_trunc_fork'
drop database if exists db_fork_basic;
alter system set _ob_enable_truncate_partition_preserve_global_index = false;
