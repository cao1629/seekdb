drop table if exists t1, t2;
create table t1(a int, b int, c int, index k1(a,b));
create table t2(a int, b int, c int, index k1(a,b) local) partition by hash(a) partitions 4;
insert into t1 values (1,1,1),(1,2,1),(2,2,2),(2,3,2),(3,3,3),(3,2,3),(4,4,4),(4,5,5);
insert into t2 values (1,1,1),(1,2,1),(2,2,2),(2,3,2),(3,3,3),(3,2,3),(4,4,4),(4,5,5);
result_format: 4
explain_protocol: 2
EXPLAIN select /*+parallel(4) index(t1 k1)*/ count(distinct a) from t1;
Query Plan
============================================================================
|ID|OPERATOR                                |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------------
|0 |SCALAR GROUP BY                         |        |1       |3           |
|1 |└─PX COORDINATOR                        |        |4       |3           |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001|4       |3           |
|3 |    └─MERGE GROUP BY                    |        |4       |2           |
|4 |      └─SUBPLAN SCAN                    |VIEW1   |8       |2           |
|5 |        └─MERGE DISTINCT                |        |8       |2           |
|6 |          └─EXCHANGE IN MERGE SORT DISTR|        |8       |2           |
|7 |            └─EXCHANGE OUT DISTR (HASH) |:EX10000|8       |2           |
|8 |              └─MERGE DISTINCT          |        |8       |1           |
|9 |                └─PX BLOCK ITERATOR     |        |8       |1           |
|10|                  └─TABLE FULL SCAN     |t1(k1)  |8       |1           |
============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.a))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.a))])
  1 - output([T_FUN_COUNT(VIEW1.t1.a)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t1.a)]), filter(nil), rowset=16
      dop=4
  3 - output([T_FUN_COUNT(VIEW1.t1.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t1.a)])
  4 - output([VIEW1.t1.a]), filter(nil), rowset=16
      access([VIEW1.t1.a])
  5 - output([t1.a]), filter(nil), rowset=16
      distinct([t1.a])
  6 - output([t1.a]), filter(nil), rowset=16
      sort_keys([t1.a, ASC])
  7 - output([t1.a]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=4
  8 - output([t1.a]), filter(nil), rowset=16
      distinct([t1.a])
  9 - output([t1.a]), filter(nil), rowset=16
      asc
 10 - output([t1.a]), filter(nil), rowset=16
      access([t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t1.a], [t1.b], [t1.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+parallel(4) index(t1 k1)*/ count(distinct a) from t1;
+-------------------+
| count(distinct a) |
+-------------------+
|                 4 |
+-------------------+
EXPLAIN select /*+parallel(4) index(t1 k1)*/ count(distinct b) from t1;
Query Plan
===========================================================================
|ID|OPERATOR                               |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------
|0 |SCALAR GROUP BY                        |        |1       |4           |
|1 |└─PX COORDINATOR                       |        |4       |4           |
|2 |  └─EXCHANGE OUT DISTR                 |:EX10001|4       |3           |
|3 |    └─MERGE GROUP BY                   |        |4       |3           |
|4 |      └─SUBPLAN SCAN                   |VIEW1   |8       |3           |
|5 |        └─HASH DISTINCT                |        |8       |3           |
|6 |          └─EXCHANGE IN DISTR          |        |8       |3           |
|7 |            └─EXCHANGE OUT DISTR (HASH)|:EX10000|8       |2           |
|8 |              └─HASH DISTINCT          |        |8       |2           |
|9 |                └─PX BLOCK ITERATOR    |        |8       |1           |
|10|                  └─TABLE FULL SCAN    |t1(k1)  |8       |1           |
===========================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.b))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.b))])
  1 - output([T_FUN_COUNT(VIEW1.t1.b)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t1.b)]), filter(nil), rowset=16
      dop=4
  3 - output([T_FUN_COUNT(VIEW1.t1.b)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t1.b)])
  4 - output([VIEW1.t1.b]), filter(nil), rowset=16
      access([VIEW1.t1.b])
  5 - output([t1.b]), filter(nil), rowset=16
      distinct([t1.b])
  6 - output([t1.b]), filter(nil), rowset=16
  7 - output([t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.b]), dop=4
  8 - output([t1.b]), filter(nil), rowset=16
      distinct([t1.b])
  9 - output([t1.b]), filter(nil), rowset=16
 10 - output([t1.b]), filter(nil), rowset=16
      access([t1.b]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t1.a], [t1.b], [t1.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+parallel(4) index(t1 k1)*/ count(distinct b) from t1;
+-------------------+
| count(distinct b) |
+-------------------+
|                 5 |
+-------------------+
EXPLAIN select /*+parallel(4) index(t1 k1)*/ count(distinct a, b) from t1;
Query Plan
============================================================================
|ID|OPERATOR                                |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------------
|0 |SCALAR GROUP BY                         |        |1       |4           |
|1 |└─PX COORDINATOR                        |        |4       |4           |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001|4       |4           |
|3 |    └─MERGE GROUP BY                    |        |4       |3           |
|4 |      └─SUBPLAN SCAN                    |VIEW1   |8       |3           |
|5 |        └─MERGE DISTINCT                |        |8       |3           |
|6 |          └─EXCHANGE IN MERGE SORT DISTR|        |8       |3           |
|7 |            └─EXCHANGE OUT DISTR (HASH) |:EX10000|8       |3           |
|8 |              └─MERGE DISTINCT          |        |8       |1           |
|9 |                └─PX BLOCK ITERATOR     |        |8       |1           |
|10|                  └─TABLE FULL SCAN     |t1(k1)  |8       |1           |
============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b))])
  1 - output([T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b)]), filter(nil), rowset=16
      dop=4
  3 - output([T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b)])
  4 - output([VIEW1.t1.a], [VIEW1.t1.b]), filter(nil), rowset=16
      access([VIEW1.t1.a], [VIEW1.t1.b])
  5 - output([t1.a], [t1.b]), filter(nil), rowset=16
      distinct([t1.a], [t1.b])
  6 - output([t1.a], [t1.b]), filter(nil), rowset=16
      sort_keys([t1.a, ASC], [t1.b, ASC])
  7 - output([t1.a], [t1.b]), filter(nil), rowset=16
      (#keys=2, [t1.a], [t1.b]), dop=4
  8 - output([t1.a], [t1.b]), filter(nil), rowset=16
      distinct([t1.a], [t1.b])
  9 - output([t1.a], [t1.b]), filter(nil), rowset=16
      asc
 10 - output([t1.a], [t1.b]), filter(nil), rowset=16
      access([t1.a], [t1.b]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t1.a], [t1.b], [t1.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+parallel(4) index(t1 k1)*/ count(distinct a, b) from t1;
+----------------------+
| count(distinct a, b) |
+----------------------+
|                    8 |
+----------------------+
EXPLAIN select /*+parallel(4) index(t1 k1)*/ count(distinct b, a) from t1;
Query Plan
============================================================================
|ID|OPERATOR                                |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------------
|0 |SCALAR GROUP BY                         |        |1       |4           |
|1 |└─PX COORDINATOR                        |        |4       |4           |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001|4       |4           |
|3 |    └─MERGE GROUP BY                    |        |4       |3           |
|4 |      └─SUBPLAN SCAN                    |VIEW1   |8       |3           |
|5 |        └─MERGE DISTINCT                |        |8       |3           |
|6 |          └─EXCHANGE IN MERGE SORT DISTR|        |8       |3           |
|7 |            └─EXCHANGE OUT DISTR (HASH) |:EX10000|8       |3           |
|8 |              └─MERGE DISTINCT          |        |8       |1           |
|9 |                └─PX BLOCK ITERATOR     |        |8       |1           |
|10|                  └─TABLE FULL SCAN     |t1(k1)  |8       |1           |
============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a))])
  1 - output([T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a)]), filter(nil), rowset=16
      dop=4
  3 - output([T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a)])
  4 - output([VIEW1.t1.b], [VIEW1.t1.a]), filter(nil), rowset=16
      access([VIEW1.t1.b], [VIEW1.t1.a])
  5 - output([t1.b], [t1.a]), filter(nil), rowset=16
      distinct([t1.a], [t1.b])
  6 - output([t1.a], [t1.b]), filter(nil), rowset=16
      sort_keys([t1.a, ASC], [t1.b, ASC])
  7 - output([t1.a], [t1.b]), filter(nil), rowset=16
      (#keys=2, [t1.a], [t1.b]), dop=4
  8 - output([t1.a], [t1.b]), filter(nil), rowset=16
      distinct([t1.a], [t1.b])
  9 - output([t1.b], [t1.a]), filter(nil), rowset=16
      asc
 10 - output([t1.b], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t1.a], [t1.b], [t1.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+parallel(4) index(t1 k1)*/ count(distinct b, a) from t1;
+----------------------+
| count(distinct b, a) |
+----------------------+
|                    8 |
+----------------------+
EXPLAIN select /*+parallel(4) index(t1 k1)*/ count(distinct a, b, c) from t1;
Query Plan
===========================================================================
|ID|OPERATOR                               |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------
|0 |SCALAR GROUP BY                        |        |1       |12          |
|1 |└─PX COORDINATOR                       |        |4       |12          |
|2 |  └─EXCHANGE OUT DISTR                 |:EX10001|4       |11          |
|3 |    └─MERGE GROUP BY                   |        |4       |11          |
|4 |      └─SUBPLAN SCAN                   |VIEW1   |8       |11          |
|5 |        └─HASH DISTINCT                |        |8       |11          |
|6 |          └─EXCHANGE IN DISTR          |        |8       |10          |
|7 |            └─EXCHANGE OUT DISTR (HASH)|:EX10000|8       |9           |
|8 |              └─HASH DISTINCT          |        |8       |7           |
|9 |                └─PX BLOCK ITERATOR    |        |8       |7           |
|10|                  └─TABLE FULL SCAN    |t1(k1)  |8       |7           |
===========================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b, VIEW1.t1.c))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b, VIEW1.t1.c))])
  1 - output([T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b, VIEW1.t1.c)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b, VIEW1.t1.c)]), filter(nil), rowset=16
      dop=4
  3 - output([T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b, VIEW1.t1.c)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t1.a, VIEW1.t1.b, VIEW1.t1.c)])
  4 - output([VIEW1.t1.a], [VIEW1.t1.b], [VIEW1.t1.c]), filter(nil), rowset=16
      access([VIEW1.t1.a], [VIEW1.t1.b], [VIEW1.t1.c])
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.a], [t1.b], [t1.c])
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  7 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=3, [t1.a], [t1.b], [t1.c]), dop=4
  8 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.a], [t1.b], [t1.c])
  9 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
 10 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), partitions(p0)
      is_index_back=true, is_global_index=false,
      range_key([t1.a], [t1.b], [t1.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+parallel(4) index(t1 k1)*/ count(distinct a, b, c) from t1;
+-------------------------+
| count(distinct a, b, c) |
+-------------------------+
|                       8 |
+-------------------------+
EXPLAIN select /*+parallel(4) index(t1 k1)*/ count(distinct b, a, c) from t1;
Query Plan
===========================================================================
|ID|OPERATOR                               |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------
|0 |SCALAR GROUP BY                        |        |1       |12          |
|1 |└─PX COORDINATOR                       |        |4       |12          |
|2 |  └─EXCHANGE OUT DISTR                 |:EX10001|4       |11          |
|3 |    └─MERGE GROUP BY                   |        |4       |11          |
|4 |      └─SUBPLAN SCAN                   |VIEW1   |8       |11          |
|5 |        └─HASH DISTINCT                |        |8       |11          |
|6 |          └─EXCHANGE IN DISTR          |        |8       |10          |
|7 |            └─EXCHANGE OUT DISTR (HASH)|:EX10000|8       |9           |
|8 |              └─HASH DISTINCT          |        |8       |7           |
|9 |                └─PX BLOCK ITERATOR    |        |8       |7           |
|10|                  └─TABLE FULL SCAN    |t1(k1)  |8       |7           |
===========================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a, VIEW1.t1.c))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a, VIEW1.t1.c))])
  1 - output([T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a, VIEW1.t1.c)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a, VIEW1.t1.c)]), filter(nil), rowset=16
      dop=4
  3 - output([T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a, VIEW1.t1.c)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t1.b, VIEW1.t1.a, VIEW1.t1.c)])
  4 - output([VIEW1.t1.b], [VIEW1.t1.a], [VIEW1.t1.c]), filter(nil), rowset=16
      access([VIEW1.t1.b], [VIEW1.t1.a], [VIEW1.t1.c])
  5 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      distinct([t1.b], [t1.a], [t1.c])
  6 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
  7 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      (#keys=3, [t1.b], [t1.a], [t1.c]), dop=4
  8 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      distinct([t1.b], [t1.a], [t1.c])
  9 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
 10 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      access([t1.__pk_increment], [t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=true, is_global_index=false,
      range_key([t1.a], [t1.b], [t1.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+parallel(4) index(t1 k1)*/ count(distinct b, a, c) from t1;
+-------------------------+
| count(distinct b, a, c) |
+-------------------------+
|                       8 |
+-------------------------+

EXPLAIN select /*+index(t1 k1)*/ count(distinct a) from t2;
Query Plan
===================================================================
|ID|OPERATOR                       |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SCALAR GROUP BY                |        |1       |10          |
|1 |└─PX COORDINATOR               |        |1       |10          |
|2 |  └─EXCHANGE OUT DISTR         |:EX10000|1       |10          |
|3 |    └─MERGE GROUP BY           |        |1       |9           |
|4 |      └─SUBPLAN SCAN           |VIEW1   |8       |9           |
|5 |        └─PX PARTITION ITERATOR|        |8       |9           |
|6 |          └─MERGE DISTINCT     |        |8       |9           |
|7 |            └─TABLE FULL SCAN  |t2(k1)  |8       |9           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.a))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.a))])
  1 - output([T_FUN_COUNT(VIEW1.t2.a)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t2.a)]), filter(nil), rowset=16
      dop=1
  3 - output([T_FUN_COUNT(VIEW1.t2.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t2.a)])
  4 - output([VIEW1.t2.a]), filter(nil), rowset=16
      access([VIEW1.t2.a])
  5 - output([t2.a]), filter(nil), rowset=16
      partition wise, force partition granule
  6 - output([t2.a]), filter(nil), rowset=16
      distinct([t2.a])
  7 - output([t2.a]), filter(nil), rowset=16
      access([t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false,
      range_key([t2.a], [t2.b], [t2.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+index(t1 k1)*/ count(distinct a) from t2;
+-------------------+
| count(distinct a) |
+-------------------+
|                 4 |
+-------------------+
EXPLAIN select /*+index(t1 k1)*/ count(distinct b) from t2;
Query Plan
===========================================================================
|ID|OPERATOR                               |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------
|0 |SCALAR GROUP BY                        |        |1       |18          |
|1 |└─PX COORDINATOR                       |        |1       |18          |
|2 |  └─EXCHANGE OUT DISTR                 |:EX10001|1       |18          |
|3 |    └─MERGE GROUP BY                   |        |1       |17          |
|4 |      └─SUBPLAN SCAN                   |VIEW1   |8       |17          |
|5 |        └─HASH DISTINCT                |        |8       |17          |
|6 |          └─EXCHANGE IN DISTR          |        |8       |15          |
|7 |            └─EXCHANGE OUT DISTR (HASH)|:EX10000|8       |14          |
|8 |              └─HASH DISTINCT          |        |8       |11          |
|9 |                └─PX PARTITION ITERATOR|        |8       |9           |
|10|                  └─TABLE FULL SCAN    |t2(k1)  |8       |9           |
===========================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.b))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.b))])
  1 - output([T_FUN_COUNT(VIEW1.t2.b)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t2.b)]), filter(nil), rowset=16
      dop=1
  3 - output([T_FUN_COUNT(VIEW1.t2.b)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t2.b)])
  4 - output([VIEW1.t2.b]), filter(nil), rowset=16
      access([VIEW1.t2.b])
  5 - output([t2.b]), filter(nil), rowset=16
      distinct([t2.b])
  6 - output([t2.b]), filter(nil), rowset=16
  7 - output([t2.b]), filter(nil), rowset=16
      (#keys=1, [t2.b]), dop=1
  8 - output([t2.b]), filter(nil), rowset=16
      distinct([t2.b])
  9 - output([t2.b]), filter(nil), rowset=16
      force partition granule
 10 - output([t2.b]), filter(nil), rowset=16
      access([t2.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false,
      range_key([t2.a], [t2.b], [t2.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+index(t1 k1)*/ count(distinct b) from t2;
+-------------------+
| count(distinct b) |
+-------------------+
|                 5 |
+-------------------+
EXPLAIN select /*+index(t1 k1)*/ count(distinct a, b) from t2;
Query Plan
===================================================================
|ID|OPERATOR                       |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SCALAR GROUP BY                |        |1       |10          |
|1 |└─PX COORDINATOR               |        |1       |10          |
|2 |  └─EXCHANGE OUT DISTR         |:EX10000|1       |10          |
|3 |    └─MERGE GROUP BY           |        |1       |10          |
|4 |      └─SUBPLAN SCAN           |VIEW1   |8       |9           |
|5 |        └─PX PARTITION ITERATOR|        |8       |9           |
|6 |          └─MERGE DISTINCT     |        |8       |9           |
|7 |            └─TABLE FULL SCAN  |t2(k1)  |8       |9           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b))])
  1 - output([T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b)]), filter(nil), rowset=16
      dop=1
  3 - output([T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b)])
  4 - output([VIEW1.t2.a], [VIEW1.t2.b]), filter(nil), rowset=16
      access([VIEW1.t2.a], [VIEW1.t2.b])
  5 - output([t2.a], [t2.b]), filter(nil), rowset=16
      partition wise, force partition granule
  6 - output([t2.a], [t2.b]), filter(nil), rowset=16
      distinct([t2.a], [t2.b])
  7 - output([t2.a], [t2.b]), filter(nil), rowset=16
      access([t2.a], [t2.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false,
      range_key([t2.a], [t2.b], [t2.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+index(t1 k1)*/ count(distinct a, b) from t2;
+----------------------+
| count(distinct a, b) |
+----------------------+
|                    8 |
+----------------------+
EXPLAIN select /*+index(t1 k1)*/ count(distinct b, a) from t2;
Query Plan
===================================================================
|ID|OPERATOR                       |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SCALAR GROUP BY                |        |1       |10          |
|1 |└─PX COORDINATOR               |        |1       |10          |
|2 |  └─EXCHANGE OUT DISTR         |:EX10000|1       |10          |
|3 |    └─MERGE GROUP BY           |        |1       |10          |
|4 |      └─SUBPLAN SCAN           |VIEW1   |8       |9           |
|5 |        └─PX PARTITION ITERATOR|        |8       |9           |
|6 |          └─MERGE DISTINCT     |        |8       |9           |
|7 |            └─TABLE FULL SCAN  |t2(k1)  |8       |9           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a))])
  1 - output([T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a)]), filter(nil), rowset=16
      dop=1
  3 - output([T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a)])
  4 - output([VIEW1.t2.b], [VIEW1.t2.a]), filter(nil), rowset=16
      access([VIEW1.t2.b], [VIEW1.t2.a])
  5 - output([t2.b], [t2.a]), filter(nil), rowset=16
      partition wise, force partition granule
  6 - output([t2.b], [t2.a]), filter(nil), rowset=16
      distinct([t2.a], [t2.b])
  7 - output([t2.a], [t2.b]), filter(nil), rowset=16
      access([t2.a], [t2.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false,
      range_key([t2.a], [t2.b], [t2.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+index(t1 k1)*/ count(distinct b, a) from t2;
+----------------------+
| count(distinct b, a) |
+----------------------+
|                    8 |
+----------------------+
EXPLAIN select /*+index(t1 k1)*/ count(distinct a, b, c) from t2;
Query Plan
===================================================================
|ID|OPERATOR                       |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SCALAR GROUP BY                |        |1       |13          |
|1 |└─PX COORDINATOR               |        |1       |13          |
|2 |  └─EXCHANGE OUT DISTR         |:EX10000|1       |13          |
|3 |    └─MERGE GROUP BY           |        |1       |12          |
|4 |      └─SUBPLAN SCAN           |VIEW1   |8       |12          |
|5 |        └─PX PARTITION ITERATOR|        |8       |12          |
|6 |          └─HASH DISTINCT      |        |8       |12          |
|7 |            └─TABLE FULL SCAN  |t2      |8       |9           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b, VIEW1.t2.c))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b, VIEW1.t2.c))])
  1 - output([T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b, VIEW1.t2.c)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b, VIEW1.t2.c)]), filter(nil), rowset=16
      dop=1
  3 - output([T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b, VIEW1.t2.c)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t2.a, VIEW1.t2.b, VIEW1.t2.c)])
  4 - output([VIEW1.t2.a], [VIEW1.t2.b], [VIEW1.t2.c]), filter(nil), rowset=16
      access([VIEW1.t2.a], [VIEW1.t2.b], [VIEW1.t2.c])
  5 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      partition wise, force partition granule
  6 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      distinct([t2.a], [t2.b], [t2.c])
  7 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false,
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+index(t1 k1)*/ count(distinct a, b, c) from t2;
+-------------------------+
| count(distinct a, b, c) |
+-------------------------+
|                       8 |
+-------------------------+
EXPLAIN select /*+index(t1 k1)*/ count(distinct b, a, c) from t2;
Query Plan
===================================================================
|ID|OPERATOR                       |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SCALAR GROUP BY                |        |1       |13          |
|1 |└─PX COORDINATOR               |        |1       |13          |
|2 |  └─EXCHANGE OUT DISTR         |:EX10000|1       |13          |
|3 |    └─MERGE GROUP BY           |        |1       |12          |
|4 |      └─SUBPLAN SCAN           |VIEW1   |8       |12          |
|5 |        └─PX PARTITION ITERATOR|        |8       |12          |
|6 |          └─HASH DISTINCT      |        |8       |12          |
|7 |            └─TABLE FULL SCAN  |t2      |8       |9           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a, VIEW1.t2.c))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a, VIEW1.t2.c))])
  1 - output([T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a, VIEW1.t2.c)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a, VIEW1.t2.c)]), filter(nil), rowset=16
      dop=1
  3 - output([T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a, VIEW1.t2.c)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t2.b, VIEW1.t2.a, VIEW1.t2.c)])
  4 - output([VIEW1.t2.b], [VIEW1.t2.a], [VIEW1.t2.c]), filter(nil), rowset=16
      access([VIEW1.t2.b], [VIEW1.t2.a], [VIEW1.t2.c])
  5 - output([t2.b], [t2.a], [t2.c]), filter(nil), rowset=16
      partition wise, force partition granule
  6 - output([t2.b], [t2.a], [t2.c]), filter(nil), rowset=16
      distinct([t2.b], [t2.a], [t2.c])
  7 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false,
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+index(t1 k1)*/ count(distinct b, a, c) from t2;
+-------------------------+
| count(distinct b, a, c) |
+-------------------------+
|                       8 |
+-------------------------+

drop table if exists t;
drop table if exists tmp;
create table t (c1 int, c2 int, key (c1, c2)) partition by hash(c2) partitions 2;
create table tmp (c1 int);
EXPLAIN insert into tmp values (0), (1), (2), (3), (4), (5), (6), (7), (8), (9);
Query Plan
==================================================
|ID|OPERATOR          |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
|0 |DISTRIBUTED INSERT|    |10      |70          |
|1 |└─EXPRESSION      |    |10      |1           |
==================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{tmp: ({tmp: (tmp.__pk_increment, tmp.c1)})}]),
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,__values.c1)])
  1 - output([__values.c1]), filter(nil)
      values({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9})
insert into tmp values (0), (1), (2), (3), (4), (5), (6), (7), (8), (9);
EXPLAIN insert into t select t1.c1 + t2.c1, t2.c1 + t1.c1 from tmp t1, tmp t2;
Query Plan
==========================================================================
|ID|OPERATOR                       |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |DISTRIBUTED INSERT             |               |100     |648         |
|1 |└─SUBPLAN SCAN                 |ANONYMOUS_VIEW1|100     |8           |
|2 |  └─NESTED-LOOP JOIN CARTESIAN |               |100     |8           |
|3 |    ├─TABLE FULL SCAN          |t1             |10      |3           |
|4 |    └─MATERIAL                 |               |10      |3           |
|5 |      └─TABLE FULL SCAN        |t2             |10      |3           |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t: ({t: (t.__pk_increment, t.c1, t.c2)})}]), partitions(p[0-1]),
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,cast(ANONYMOUS_VIEW1.t1.c1 + t2.c1, INT(-1, 0)))], [column_conv(INT,PS:(11,0),NULL,cast(ANONYMOUS_VIEW1.t2.c1
      + t1.c1, INT(-1, 0)))])
  1 - output([ANONYMOUS_VIEW1.t1.c1 + t2.c1], [ANONYMOUS_VIEW1.t2.c1 + t1.c1]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.t1.c1 + t2.c1], [ANONYMOUS_VIEW1.t2.c1 + t1.c1])
  2 - output([t1.c1 + t2.c1], [t2.c1 + t1.c1]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  3 - output([t1.c1]), filter(nil), rowset=16
      access([t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  4 - output([t2.c1]), filter(nil), rowset=16
  5 - output([t2.c1]), filter(nil), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
insert into t select t1.c1 + t2.c1, t2.c1 + t1.c1 from tmp t1, tmp t2;
alter system minor freeze;
call dbms_stats.gather_table_stats('TEST', 't');
call dbms_stats.gather_table_stats('TEST', 'tmp');

EXPLAIN select /*+parallel(8)*/ count(distinct c2) from t;
Query Plan
=================================================================================
|ID|OPERATOR                                     |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                              |        |1       |13          |
|1 |└─PX COORDINATOR                             |        |8       |13          |
|2 |  └─EXCHANGE OUT DISTR                       |:EX10001|8       |12          |
|3 |    └─MERGE GROUP BY                         |        |8       |11          |
|4 |      └─SUBPLAN SCAN                         |VIEW1   |19      |11          |
|5 |        └─HASH DISTINCT                      |        |19      |11          |
|6 |          └─EXCHANGE IN DISTR                |        |77      |10          |
|7 |            └─EXCHANGE OUT DISTR (HASH LOCAL)|:EX10000|77      |8           |
|8 |              └─HASH DISTINCT                |        |77      |4           |
|9 |                └─PX BLOCK ITERATOR          |        |100     |1           |
|10|                  └─TABLE FULL SCAN          |t       |100     |1           |
=================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t.c2))]), filter(nil), rowset=256
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t.c2))])
  1 - output([T_FUN_COUNT(VIEW1.t.c2)]), filter(nil), rowset=256
  2 - output([T_FUN_COUNT(VIEW1.t.c2)]), filter(nil), rowset=256
      dop=8
  3 - output([T_FUN_COUNT(VIEW1.t.c2)]), filter(nil), rowset=256
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t.c2)])
  4 - output([VIEW1.t.c2]), filter(nil), rowset=256
      access([VIEW1.t.c2])
  5 - output([t.c2]), filter(nil), rowset=256
      distinct([t.c2])
  6 - output([t.c2]), filter(nil), rowset=256
  7 - output([t.c2]), filter(nil), rowset=256
      (#keys=1, [t.c2]), dop=8
  8 - output([t.c2]), filter(nil), rowset=256
      distinct([t.c2])
  9 - output([t.c2]), filter(nil), rowset=256
 10 - output([t.c2]), filter(nil), rowset=256
      access([t.c2]), partitions(p[0-1])
      is_index_back=false, is_global_index=false,
      range_key([t.__pk_increment]), range(MIN ; MAX)always true
select /*+parallel(8)*/ count(distinct c2) from t;
+--------------------+
| count(distinct c2) |
+--------------------+
|                 19 |
+--------------------+
EXPLAIN select /*+parallel(8)*/ count(distinct c2) from (select /*+no_merge*/ * from t) v;
Query Plan
=================================================================================
|ID|OPERATOR                                     |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                              |        |1       |12          |
|1 |└─PX COORDINATOR                             |        |8       |12          |
|2 |  └─EXCHANGE OUT DISTR                       |:EX10001|8       |10          |
|3 |    └─MERGE GROUP BY                         |        |8       |10          |
|4 |      └─SUBPLAN SCAN                         |VIEW1   |19      |10          |
|5 |        └─HASH DISTINCT                      |        |19      |10          |
|6 |          └─EXCHANGE IN DISTR                |        |77      |9           |
|7 |            └─EXCHANGE OUT DISTR (HASH LOCAL)|:EX10000|77      |7           |
|8 |              └─HASH DISTINCT                |        |77      |4           |
|9 |                └─SUBPLAN SCAN               |v       |100     |1           |
|10|                  └─PX BLOCK ITERATOR        |        |100     |1           |
|11|                    └─TABLE FULL SCAN        |t       |100     |1           |
=================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.v.c2))]), filter(nil), rowset=256
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.v.c2))])
  1 - output([T_FUN_COUNT(VIEW1.v.c2)]), filter(nil), rowset=256
  2 - output([T_FUN_COUNT(VIEW1.v.c2)]), filter(nil), rowset=256
      dop=8
  3 - output([T_FUN_COUNT(VIEW1.v.c2)]), filter(nil), rowset=256
      group(nil), agg_func([T_FUN_COUNT(VIEW1.v.c2)])
  4 - output([VIEW1.v.c2]), filter(nil), rowset=256
      access([VIEW1.v.c2])
  5 - output([v.c2]), filter(nil), rowset=256
      distinct([v.c2])
  6 - output([v.c2]), filter(nil), rowset=256
  7 - output([v.c2]), filter(nil), rowset=256
      (#keys=1, [v.c2]), dop=8
  8 - output([v.c2]), filter(nil), rowset=256
      distinct([v.c2])
  9 - output([v.c2]), filter(nil), rowset=256
      access([v.c2])
 10 - output([t.c2]), filter(nil), rowset=256
 11 - output([t.c2]), filter(nil), rowset=256
      access([t.c2]), partitions(p[0-1])
      is_index_back=false, is_global_index=false,
      range_key([t.__pk_increment]), range(MIN ; MAX)always true
select /*+parallel(8)*/ count(distinct c2) from (select /*+no_merge*/ * from t) v;
+--------------------+
| count(distinct c2) |
+--------------------+
|                 19 |
+--------------------+
EXPLAIN select /*+parallel(8)*/ count(distinct c2) from t group by c1;
Query Plan
=====================================================================================
|ID|OPERATOR                                         |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |PX COORDINATOR                                   |        |19      |27          |
|1 |└─EXCHANGE OUT DISTR                             |:EX10002|19      |24          |
|2 |  └─MERGE GROUP BY                               |        |19      |23          |
|3 |    └─EXCHANGE IN MERGE SORT DISTR               |        |71      |23          |
|4 |      └─EXCHANGE OUT DISTR (HASH)                |:EX10001|71      |22          |
|5 |        └─MERGE GROUP BY                         |        |71      |18          |
|6 |          └─SUBPLAN SCAN                         |VIEW1   |90      |18          |
|7 |            └─MERGE DISTINCT                     |        |90      |18          |
|8 |              └─EXCHANGE IN MERGE SORT DISTR     |        |100     |17          |
|9 |                └─EXCHANGE OUT DISTR (HASH LOCAL)|:EX10000|100     |12          |
|10|                  └─PX BLOCK ITERATOR            |        |100     |2           |
|11|                    └─MERGE DISTINCT             |        |100     |2           |
|12|                      └─TABLE FULL SCAN          |t(c1)   |100     |2           |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t.c2)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t.c2)))]), filter(nil), rowset=256
      dop=8
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t.c2))]), filter(nil), rowset=256
      group([VIEW1.t.c1]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t.c2))])
  3 - output([VIEW1.t.c1], [T_FUN_COUNT(VIEW1.t.c2)]), filter(nil), rowset=256
      sort_keys([VIEW1.t.c1, ASC])
  4 - output([VIEW1.t.c1], [T_FUN_COUNT(VIEW1.t.c2)]), filter(nil), rowset=256
      (#keys=1, [VIEW1.t.c1]), dop=8
  5 - output([VIEW1.t.c1], [T_FUN_COUNT(VIEW1.t.c2)]), filter(nil), rowset=256
      group([VIEW1.t.c1]), agg_func([T_FUN_COUNT(VIEW1.t.c2)])
  6 - output([VIEW1.t.c2], [VIEW1.t.c1]), filter(nil), rowset=256
      access([VIEW1.t.c2], [VIEW1.t.c1])
  7 - output([t.c2], [t.c1]), filter(nil), rowset=256
      distinct([t.c1], [t.c2])
  8 - output([t.c1], [t.c2]), filter(nil), rowset=256
      sort_keys([t.c1, ASC], [t.c2, ASC]), Local Order
  9 - output([t.c1], [t.c2]), filter(nil), rowset=256
      (#keys=2, [t.c1], [t.c2]), dop=8
 10 - output([t.c1], [t.c2]), filter(nil), rowset=256
 11 - output([t.c1], [t.c2]), filter(nil), rowset=256
      distinct([t.c1], [t.c2])
 12 - output([t.c2], [t.c1]), filter(nil), rowset=256
      access([t.c2], [t.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false,
      range_key([t.c1], [t.c2], [t.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+parallel(8)*/ count(distinct c2) from t group by c1;
+--------------------+
| count(distinct c2) |
+--------------------+
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
+--------------------+
EXPLAIN select /*+parallel(8)*/ count(c2) from t;
Query Plan
=============================================================
|ID|OPERATOR                 |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1       |3           |
|1 |└─PX COORDINATOR         |        |8       |3           |
|2 |  └─EXCHANGE OUT DISTR   |:EX10000|8       |2           |
|3 |    └─MERGE GROUP BY     |        |8       |2           |
|4 |      └─PX BLOCK ITERATOR|        |100     |1           |
|5 |        └─TABLE FULL SCAN|t       |100     |1           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2)))]), filter(nil), rowset=256
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2)))])
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2))]), filter(nil), rowset=256
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2))]), filter(nil), rowset=256
      dop=8
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2))]), filter(nil), rowset=256
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2))])
  4 - output([T_FUN_COUNT(t.c2)]), filter(nil), rowset=256
  5 - output([T_FUN_COUNT(t.c2)]), filter(nil), rowset=256
      access([t.c2]), partitions(p[0-1])
      is_index_back=false, is_global_index=false,
      range_key([t.__pk_increment]), range(MIN ; MAX)always true,
      pushdown_aggregation([T_FUN_COUNT(t.c2)])
select /*+parallel(8)*/ count(c2) from t;
+-----------+
| count(c2) |
+-----------+
|       100 |
+-----------+
EXPLAIN select /*+parallel(8)*/ count(c2) from t group by c1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |19      |12          |
|1 |└─EXCHANGE OUT DISTR              |:EX10001|19      |9           |
|2 |  └─MERGE GROUP BY                |        |19      |8           |
|3 |    └─EXCHANGE IN MERGE SORT DISTR|        |77      |8           |
|4 |      └─EXCHANGE OUT DISTR (HASH) |:EX10000|77      |6           |
|5 |        └─PX BLOCK ITERATOR       |        |77      |3           |
|6 |          └─MERGE GROUP BY        |        |77      |3           |
|7 |            └─TABLE FULL SCAN     |t(c1)   |100     |2           |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2)))]), filter(nil), rowset=256
      dop=8
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2))]), filter(nil), rowset=256
      group([t.c1]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2))])
  3 - output([t.c1], [T_FUN_COUNT(t.c2)]), filter(nil), rowset=256
      sort_keys([t.c1, ASC]), Local Order
  4 - output([t.c1], [T_FUN_COUNT(t.c2)]), filter(nil), rowset=256
      (#keys=1, [t.c1]), dop=8
  5 - output([t.c1], [T_FUN_COUNT(t.c2)]), filter(nil), rowset=256
  6 - output([t.c1], [T_FUN_COUNT(t.c2)]), filter(nil), rowset=256
      group([t.c1]), agg_func([T_FUN_COUNT(t.c2)])
  7 - output([t.c2], [t.c1]), filter(nil), rowset=256
      access([t.c2], [t.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false,
      range_key([t.c1], [t.c2], [t.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+parallel(8)*/ count(c2) from t group by c1;
+-----------+
| count(c2) |
+-----------+
|         1 |
|         1 |
|         2 |
|         2 |
|         3 |
|         3 |
|         4 |
|         4 |
|         5 |
|         5 |
|         6 |
|         6 |
|         7 |
|         7 |
|         8 |
|         8 |
|         9 |
|         9 |
|        10 |
+-----------+
EXPLAIN select /*+parallel(8)*/ count(c2) from t group by c1 + 1;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |19      |15          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|19      |12          |
|2 |  └─HASH GROUP BY                |        |19      |11          |
|3 |    └─EXCHANGE IN DISTR          |        |77      |10          |
|4 |      └─EXCHANGE OUT DISTR (HASH)|:EX10000|77      |8           |
|5 |        └─HASH GROUP BY          |        |77      |5           |
|6 |          └─PX BLOCK ITERATOR    |        |100     |2           |
|7 |            └─TABLE FULL SCAN    |t       |100     |2           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2)))]), filter(nil), rowset=256
      dop=8
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2))]), filter(nil), rowset=256
      group([t.c1 + 1]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c2))])
  3 - output([t.c1 + 1], [T_FUN_COUNT(t.c2)]), filter(nil), rowset=256
  4 - output([t.c1 + 1], [T_FUN_COUNT(t.c2)]), filter(nil), rowset=256
      (#keys=1, [t.c1 + 1]), dop=8
  5 - output([t.c1 + 1], [T_FUN_COUNT(t.c2)]), filter(nil), rowset=256
      group([t.c1 + 1]), agg_func([T_FUN_COUNT(t.c2)])
  6 - output([t.c2], [t.c1 + 1]), filter(nil), rowset=256
  7 - output([t.c2], [t.c1 + 1]), filter(nil), rowset=256
      access([t.c2], [t.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false,
      range_key([t.__pk_increment]), range(MIN ; MAX)always true
select /*+parallel(8)*/ count(c2) from t group by c1 + 1;
+-----------+
| count(c2) |
+-----------+
|         1 |
|         1 |
|         2 |
|         2 |
|         3 |
|         3 |
|         4 |
|         4 |
|         5 |
|         5 |
|         6 |
|         6 |
|         7 |
|         7 |
|         8 |
|         8 |
|         9 |
|         9 |
|        10 |
+-----------+

EXPLAIN select /*+parallel(8)*/ count(distinct c1) from t;
Query Plan
============================================================================
|ID|OPERATOR                                |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------------
|0 |SCALAR GROUP BY                         |        |1       |10          |
|1 |└─PX COORDINATOR                        |        |8       |10          |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001|8       |8           |
|3 |    └─MERGE GROUP BY                    |        |8       |8           |
|4 |      └─SUBPLAN SCAN                    |VIEW1   |19      |8           |
|5 |        └─MERGE DISTINCT                |        |19      |8           |
|6 |          └─EXCHANGE IN MERGE SORT DISTR|        |77      |8           |
|7 |            └─EXCHANGE OUT DISTR (HASH) |:EX10000|77      |6           |
|8 |              └─PX BLOCK ITERATOR       |        |77      |2           |
|9 |                └─MERGE DISTINCT        |        |77      |2           |
|10|                  └─TABLE FULL SCAN     |t(c1)   |100     |2           |
============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t.c1))]), filter(nil), rowset=256
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(VIEW1.t.c1))])
  1 - output([T_FUN_COUNT(VIEW1.t.c1)]), filter(nil), rowset=256
  2 - output([T_FUN_COUNT(VIEW1.t.c1)]), filter(nil), rowset=256
      dop=8
  3 - output([T_FUN_COUNT(VIEW1.t.c1)]), filter(nil), rowset=256
      group(nil), agg_func([T_FUN_COUNT(VIEW1.t.c1)])
  4 - output([VIEW1.t.c1]), filter(nil), rowset=256
      access([VIEW1.t.c1])
  5 - output([t.c1]), filter(nil), rowset=256
      distinct([t.c1])
  6 - output([t.c1]), filter(nil), rowset=256
      sort_keys([t.c1, ASC]), Local Order
  7 - output([t.c1]), filter(nil), rowset=256
      (#keys=1, [t.c1]), dop=8
  8 - output([t.c1]), filter(nil), rowset=256
  9 - output([t.c1]), filter(nil), rowset=256
      distinct([t.c1])
 10 - output([t.c1]), filter(nil), rowset=256
      access([t.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false,
      range_key([t.c1], [t.c2], [t.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+parallel(8)*/ count(distinct c1) from t;
+--------------------+
| count(distinct c1) |
+--------------------+
|                 19 |
+--------------------+
EXPLAIN select /*+parallel(8)*/ count(distinct c1) from t group by c1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |19      |13          |
|1 |└─EXCHANGE OUT DISTR              |:EX10001|19      |10          |
|2 |  └─MERGE GROUP BY                |        |19      |9           |
|3 |    └─EXCHANGE IN MERGE SORT DISTR|        |77      |8           |
|4 |      └─EXCHANGE OUT DISTR (HASH) |:EX10000|77      |6           |
|5 |        └─PX BLOCK ITERATOR       |        |77      |2           |
|6 |          └─MERGE GROUP BY        |        |77      |2           |
|7 |            └─TABLE FULL SCAN     |t(c1)   |100     |2           |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(CASE WHEN t.c1 IS NOT NULL THEN 1 ELSE 0 END)]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(CASE WHEN t.c1 IS NOT NULL THEN 1 ELSE 0 END)]), filter(nil), rowset=256
      dop=8
  2 - output([t.c1]), filter(nil), rowset=256
      group([t.c1]), agg_func(nil)
  3 - output([t.c1]), filter(nil), rowset=256
      sort_keys([t.c1, ASC]), Local Order
  4 - output([t.c1]), filter(nil), rowset=256
      (#keys=1, [t.c1]), dop=8
  5 - output([t.c1]), filter(nil), rowset=256
  6 - output([t.c1]), filter(nil), rowset=256
      group([t.c1]), agg_func(nil)
  7 - output([t.c1]), filter(nil), rowset=256
      access([t.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false,
      range_key([t.c1], [t.c2], [t.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+parallel(8)*/ count(distinct c1) from t group by c1;
+--------------------+
| count(distinct c1) |
+--------------------+
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
|                  1 |
+--------------------+
EXPLAIN select /*+parallel(8)*/ count(c1) from t;
Query Plan
=============================================================
|ID|OPERATOR                 |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1       |4           |
|1 |└─PX COORDINATOR         |        |8       |3           |
|2 |  └─EXCHANGE OUT DISTR   |:EX10000|8       |2           |
|3 |    └─MERGE GROUP BY     |        |8       |2           |
|4 |      └─PX BLOCK ITERATOR|        |100     |2           |
|5 |        └─TABLE FULL SCAN|t       |100     |2           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT_SUM(T_FUN_COUNT(t.c1)))]), filter(nil), rowset=256
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT_SUM(T_FUN_COUNT(t.c1)))])
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c1))]), filter(nil), rowset=256
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c1))]), filter(nil), rowset=256
      dop=8
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c1))]), filter(nil), rowset=256
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c1))])
  4 - output([T_FUN_COUNT(t.c1)]), filter(nil), rowset=256
  5 - output([T_FUN_COUNT(t.c1)]), filter(nil), rowset=256
      access([t.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false,
      range_key([t.__pk_increment]), range(MIN ; MAX)always true,
      pushdown_aggregation([T_FUN_COUNT(t.c1)])
select /*+parallel(8)*/ count(c1) from t;
+-----------+
| count(c1) |
+-----------+
|       100 |
+-----------+
EXPLAIN select /*+parallel(8)*/ count(c1) from t group by c1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |19      |11          |
|1 |└─EXCHANGE OUT DISTR              |:EX10001|19      |9           |
|2 |  └─MERGE GROUP BY                |        |19      |8           |
|3 |    └─EXCHANGE IN MERGE SORT DISTR|        |77      |7           |
|4 |      └─EXCHANGE OUT DISTR (HASH) |:EX10000|77      |6           |
|5 |        └─PX BLOCK ITERATOR       |        |77      |2           |
|6 |          └─MERGE GROUP BY        |        |77      |2           |
|7 |            └─TABLE FULL SCAN     |t(c1)   |100     |2           |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t.c1)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t.c1)))]), filter(nil), rowset=256
      dop=8
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c1))]), filter(nil), rowset=256
      group([t.c1]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t.c1))])
  3 - output([t.c1], [T_FUN_COUNT(t.c1)]), filter(nil), rowset=256
      sort_keys([t.c1, ASC]), Local Order
  4 - output([t.c1], [T_FUN_COUNT(t.c1)]), filter(nil), rowset=256
      (#keys=1, [t.c1]), dop=8
  5 - output([t.c1], [T_FUN_COUNT(t.c1)]), filter(nil), rowset=256
  6 - output([t.c1], [T_FUN_COUNT(t.c1)]), filter(nil), rowset=256
      group([t.c1]), agg_func([T_FUN_COUNT(t.c1)])
  7 - output([t.c1]), filter(nil), rowset=256
      access([t.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false,
      range_key([t.c1], [t.c2], [t.__pk_increment]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select /*+parallel(8)*/ count(c1) from t group by c1;
+-----------+
| count(c1) |
+-----------+
|         1 |
|         1 |
|         2 |
|         2 |
|         3 |
|         3 |
|         4 |
|         4 |
|         5 |
|         5 |
|         6 |
|         6 |
|         7 |
|         7 |
|         8 |
|         8 |
|         9 |
|         9 |
|        10 |
+-----------+
