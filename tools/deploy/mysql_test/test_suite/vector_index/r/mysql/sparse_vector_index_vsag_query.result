alter system set ob_vector_memory_limit_percentage = 44;
# 单分区查询: 全是增量数据
drop table if exists t1;
CREATE TABLE t1 (
c1 int primary key,
c2 sparsevector,
vector index idx1(c2) with (lib=vsag, type=sindi, distance=inner_product)
);
insert into t1 values(1, '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, '{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(10, '{11:1.1, 10:1.0, 12:1.2}');
call dbms_stats.gather_table_stats('test','t1');
select * from t1 order by negative_inner_product(c2, '{}') approx limit 2;
c1	c2
select * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select /*+ opt_param('rowsets_enabled', 'false')*/ * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
1	{1:0.1,2:0.2,3:0.3}
select * from t1 where c1 <= 5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select /*+ parallel(8)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select /*+ index(t1 idx1)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0);
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0.2);
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0.9);
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=0.9);
ERROR HY000: Incorrect arguments to vector index refine_k value
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1000);
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(drop_ratio_search=0.95);
ERROR HY000: Incorrect arguments to vector index drop_ratio_search value
explain select * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
=====================================================
|ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |VECTOR INDEX SCAN|t1(idx1)|10      |29          |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false,
      range_key([t1.__vid_0], [t1.__type_0_0]), range(MIN,MIN ; MAX,MAX)always true
explain select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
========================================================================
|ID|OPERATOR                                |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1  |2       |3           |
========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 < 3]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 3)
explain select * from t1 where c1 > 10 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
=======================================================================
|ID|OPERATOR                               |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1  |1       |3           |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 > 10]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(10 ; MAX)
explain select /*+ index(t1 idx1)*/ * from t1 where c1 > 10 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
========================================================================
|ID|OPERATOR                                |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1  |1       |3           |
========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 > 10]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(10 ; MAX)
explain select /*+ index(t1 primary)*/ * from t1 where c1 <= 5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
=======================================================================
|ID|OPERATOR                               |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1  |5       |3           |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 <= 5]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 5]
# 单分区查询: 全是快照数据
drop table if exists t1;
CREATE TABLE t1 (
c1 int primary key,
c2 sparsevector
);
insert into t1 values(1, '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, '{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(10, '{11:1.1, 10:1.0, 12:1.2}');
create vector index idx1 on t1(c2) with (lib=vsag, type=sindi, distance=inner_product);
call dbms_stats.gather_table_stats('test','t1');
select * from t1 order by negative_inner_product(c2, '{}') approx limit 2;
c1	c2
select * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select /*+ opt_param('rowsets_enabled', 'false')*/ * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
1	{1:0.1,2:0.2,3:0.3}
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select * from t1 where c1 <= 5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select /*+ parallel(8)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select /*+ index(t1 idx1)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0);
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0.2);
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0.5);
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
explain select * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
=====================================================
|ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |VECTOR INDEX SCAN|t1(idx1)|1       |7           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false,
      range_key([t1.__vid_0], [t1.__type_0_0]), range(MIN,MIN ; MAX,MAX)always true
explain select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
========================================================================
|ID|OPERATOR                                |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1  |2       |3           |
========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 < 3]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 3)
explain select /*+ index(t1 idx1)*/ * from t1 where c1 > 10 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
========================================================================
|ID|OPERATOR                                |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1  |1       |3           |
========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 > 10]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(10 ; MAX)
explain select /*+ index(t1 primary)*/ * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
=======================================================================
|ID|OPERATOR                               |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1  |2       |3           |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 < 3]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 3)
# 单分区查询: 快照+增量数据
drop table if exists t1;
alter system set vector_index_optimize_duty_time='[24:00:00, 24:00:00]';
CREATE TABLE t1 (
c1 int primary key,
c2 sparsevector
);
insert into t1 values(1, '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, '{9:0.9, 10:1.0, 11:1.1}');
create vector index idx1 on t1(c2) with (lib=vsag, type=sindi, distance=inner_product);
call dbms_stats.gather_table_stats('test','t1');
insert into t1 values(10, '{11:1.1, 10:1.0, 12:1.2}');
select * from t1 order by negative_inner_product(c2, '{}') approx limit 2;
c1	c2
select * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 order by negative_inner_product(c2, '{10:1, 11:1}') approx limit 2;
c1	c2
10	{10:1,11:1.1,12:1.2}
9	{9:0.9,10:1,11:1.1}
select * from t1 order by negative_inner_product(c2, '{11:1, 12:1}') approx limit 2;
c1	c2
10	{10:1,11:1.1,12:1.2}
select * from t1 order by negative_inner_product(c2, '{12:1, 13:1}') approx limit 2;
c1	c2
select /*+ opt_param('rowsets_enabled', 'false')*/ * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
1	{1:0.1,2:0.2,3:0.3}
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{10:1, 11:1}') approx limit 2;
c1	c2
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{11:1, 12:1}') approx limit 2;
c1	c2
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{12:1, 13:1}') approx limit 2;
c1	c2
select * from t1 where c1 <= 5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select /*+ parallel(8)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select /*+ index(t1 idx1)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0);
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0.2);
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0.5);
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
explain select * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
=====================================================
|ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |VECTOR INDEX SCAN|t1(idx1)|1       |7           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false,
      range_key([t1.__vid_0], [t1.__type_0_0]), range(MIN,MIN ; MAX,MAX)always true
explain select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
========================================================================
|ID|OPERATOR                                |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1  |2       |3           |
========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 < 3]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 3)
explain select /*+ index(t1 idx1)*/ * from t1 where c1 > 10 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
========================================================================
|ID|OPERATOR                                |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1  |1       |3           |
========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 > 10]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(10 ; MAX)
explain select /*+ index(t1 primary)*/ * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
=======================================================================
|ID|OPERATOR                               |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1  |2       |3           |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 < 3]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 3)
alter system set vector_index_optimize_duty_time='[00:00:00, 24:00:00]';
drop table if exists t1;
# 单分区查询: 构建参数+查询参数
alter system set vector_index_optimize_duty_time='[24:00:00, 24:00:00]';
CREATE TABLE t1 (
c1 int primary key,
c2 sparsevector
);
insert into t1 values(1, '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, '{9:0.9, 10:1.0, 11:1.1}');
create vector index idx1 on t1(c2) with (lib=vsag, type=sindi, distance=inner_product, drop_ratio_search=0.5);
insert into t1 values(10, '{11:1.1, 10:1.0, 12:1.2}');
select * from t1 order by negative_inner_product(c2, '{}') approx limit 2;
c1	c2
select * from t1 order by negative_inner_product(c2, '{3:0.3, 4:0.4}') approx limit 4;
c1	c2
4	{4:0.4,5:0.5,6:0.6}
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 order by negative_inner_product(c2, '{3:0.3, 4:0.4}') approx limit 4 parameters(drop_ratio_search=0);
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
4	{4:0.4,5:0.5,6:0.6}
1	{1:0.1,2:0.2,3:0.3}
select * from t1 order by negative_inner_product(c2, '{3:0.3, 4:0.4}') approx limit 4 parameters(drop_ratio_search=0.2);
c1	c2
4	{4:0.4,5:0.5,6:0.6}
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select * from t1 order by negative_inner_product(c2, '{10:1, 11:1.1}') approx limit 4;
c1	c2
10	{10:1,11:1.1,12:1.2}
9	{9:0.9,10:1,11:1.1}
select * from t1 order by negative_inner_product(c2, '{10:1, 11:1.1}') approx limit 4 parameters(drop_ratio_search=0);
c1	c2
10	{10:1,11:1.1,12:1.2}
9	{9:0.9,10:1,11:1.1}
8	{8:0.8,9:0.9,10:1}
select * from t1 order by negative_inner_product(c2, '{11:1.1, 12:1.2}') approx limit 4;
c1	c2
10	{10:1,11:1.1,12:1.2}
select * from t1 order by negative_inner_product(c2, '{11:1.1, 12:1.2}') approx limit 4 parameters(drop_ratio_search=0);
c1	c2
10	{10:1,11:1.1,12:1.2}
9	{9:0.9,10:1,11:1.1}
select * from t1 order by negative_inner_product(c2, '{12:1.2, 13:1.3}') approx limit 4;
c1	c2
select * from t1 order by negative_inner_product(c2, '{12:1.2, 13:1.3}') approx limit 4 parameters(drop_ratio_search=0);
c1	c2
10	{10:1,11:1.1,12:1.2}
select /*+ opt_param('rowsets_enabled', 'false')*/ * from t1 order by negative_inner_product(c2, '{3:0.3, 4:0.4}') approx limit 4;
c1	c2
4	{4:0.4,5:0.5,6:0.6}
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select /*+ opt_param('rowsets_enabled', 'false')*/ * from t1 order by negative_inner_product(c2, '{3:0.3, 4:0.4}') approx limit 4 parameters(drop_ratio_search=0);
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
4	{4:0.4,5:0.5,6:0.6}
1	{1:0.1,2:0.2,3:0.3}
select /*+ parallel(8)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:0.3, 4:0.4}') approx limit 4;
c1	c2
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
4	{4:0.4,5:0.5,6:0.6}
select /*+ parallel(8)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:0.3, 4:0.4}') approx limit 4 parameters(drop_ratio_search=0);
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
4	{4:0.4,5:0.5,6:0.6}
1	{1:0.1,2:0.2,3:0.3}
select /*+ index(t1 idx1)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:0.3, 4:0.4}') approx limit 4;
c1	c2
4	{4:0.4,5:0.5,6:0.6}
3	{3:0.3,4:0.4,5:0.5}
2	{2:0.2,3:0.3,4:0.4}
select /*+ index(t1 idx1)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:0.3, 4:0.4}') approx limit 4 parameters(drop_ratio_search=0);
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
4	{4:0.4,5:0.5,6:0.6}
1	{1:0.1,2:0.2,3:0.3}
alter system set vector_index_optimize_duty_time='[00:00:00, 24:00:00]';
drop index idx1 on t1;
create vector index idx1 on t1(c2) with (lib=vsag, type=sindi, distance=inner_product, prune=true, drop_ratio_build=0.5, drop_ratio_search=0);
select * from t1 order by negative_inner_product(c2, '{3:0.3, 4:0.4}') approx limit 4;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
1	{1:0.1,2:0.2,3:0.3}
select * from t1 order by negative_inner_product(c2, '{10:1, 11:1.1}') approx limit 4;
c1	c2
9	{9:0.9,10:1,11:1.1}
8	{8:0.8,9:0.9,10:1}
select * from t1 order by negative_inner_product(c2, '{11:1.1, 12:1.2}') approx limit 4;
c1	c2
10	{10:1,11:1.1,12:1.2}
9	{9:0.9,10:1,11:1.1}
select * from t1 order by negative_inner_product(c2, '{12:1.2, 13:1.3}') approx limit 4;
c1	c2
10	{10:1,11:1.1,12:1.2}
drop table if exists t1;
CREATE TABLE t1 ( c1 int primary key, c2 sparsevector);
insert into t1 values(1, '{1:0.1, 2:0.7, 3:0.3}');
insert into t1 values(2, '{1:0.3, 2:0.6, 3:0.4}');
insert into t1 values(3, '{1:0.3, 2:0.3, 3:0.5}');
insert into t1 values(4, '{1:0.5, 2:0.2, 3:0.6}');
insert into t1 values(5, '{1:0.5, 2:0.1, 3:0.7}');
create vector index idx1 on t1(c2) with (lib=vsag, type=sindi, distance=inner_product, prune=true, refine=true, drop_ratio_build=0.5);
default refine_k=4
select *, negative_inner_product(c2, '{2:0.2, 3:0.3}') as score from t1 order by score approx limit 4;
c1	c2	score
2	{1:0.3,2:0.6,3:0.4}	-0.24000000953674316
5	{1:0.5,2:0.1,3:0.7}	-0.23000000976026058
1	{1:0.1,2:0.7,3:0.3}	-0.23000000417232513
4	{1:0.5,2:0.2,3:0.6}	-0.220000009983778
select *, negative_inner_product(c2, '{2:0.2, 3:0.3}') as score from t1 order by score approx limit 4 parameters(refine_k=4);
c1	c2	score
2	{1:0.3,2:0.6,3:0.4}	-0.24000000953674316
5	{1:0.5,2:0.1,3:0.7}	-0.23000000976026058
1	{1:0.1,2:0.7,3:0.3}	-0.23000000417232513
4	{1:0.5,2:0.2,3:0.6}	-0.220000009983778
select *, negative_inner_product(c2, '{2:0.2, 3:0.3}') as score from t1 order by score approx limit 4 parameters(refine_k=2);
c1	c2	score
2	{1:0.3,2:0.6,3:0.4}	-0.24000000953674316
5	{1:0.5,2:0.1,3:0.7}	-0.23000000976026058
1	{1:0.1,2:0.7,3:0.3}	-0.23000000417232513
4	{1:0.5,2:0.2,3:0.6}	-0.220000009983778
select *, negative_inner_product(c2, '{2:0.2, 3:0.3}') as score from t1 order by score approx limit 4 parameters(refine_k=1);
c1	c2	score
5	{1:0.5,2:0.1,3:0.7}	-0.23000000976026058
1	{1:0.1,2:0.7,3:0.3}	-0.23000000417232513
4	{1:0.5,2:0.2,3:0.6}	-0.220000009983778
3	{1:0.3,2:0.3,3:0.5}	-0.21000000834465027
alter system set vector_index_optimize_duty_time='[00:00:00, 24:00:00]';
# 多分区查询: 增量数据
drop table if exists t1;
CREATE TABLE t1 (
c1 int primary key,
c2 sparsevector,
vector index idx1(c2) with (lib=vsag, type=sindi, distance=inner_product)
) partition by hash(c1) partitions 3;
insert into t1 values(1, '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, '{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(10, '{11:1.1, 10:1.0, 12:1.2}');
call dbms_stats.gather_table_stats('test','t1');
select * from t1 order by negative_inner_product(c2, '{}') approx limit 2;
c1	c2
select * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select * from t1 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
1	{1:0.1,2:0.2,3:0.3}
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select * from t1 where c1 <= 5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select /*+ opt_param('rowsets_enabled', 'false')*/ * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select /*+ parallel(8)*/ negative_inner_product(c2, '{3:1, 4:1}') from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
negative_inner_product(c2, '{3:1, 4:1}')
-0.7000000178813934
-0.7000000178813934
select /*+ index(t1 idx1)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0);
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0.5);
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=0.9);
ERROR HY000: Incorrect arguments to vector index refine_k value
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1000);
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(drop_ratio_search=0.95);
ERROR HY000: Incorrect arguments to vector index drop_ratio_search value
explain select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |2       |10          |
|1 |└─PX COORDINATOR MERGE SORT                       |        |2       |10          |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|2       |9           |
|3 |    └─TOP-N SORT                                  |        |2       |7           |
|4 |      └─PX PARTITION ITERATOR                     |        |2       |7           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |2       |7           |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(2)
  4 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 3]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-2])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 3)
explain select /*+ index(t1 idx1)*/ * from t1 where c1 > 10 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |1       |8           |
|1 |└─PX COORDINATOR MERGE SORT                       |        |1       |8           |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|1       |8           |
|3 |    └─TOP-N SORT                                  |        |1       |7           |
|4 |      └─PX PARTITION ITERATOR                     |        |1       |7           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |1       |7           |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(2)
  4 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 > 10]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-2])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(10 ; MAX)
explain select /*+ index(t1 primary)*/ * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
=====================================================================================
|ID|OPERATOR                                         |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |LIMIT                                            |        |2       |10          |
|1 |└─PX COORDINATOR MERGE SORT                      |        |2       |10          |
|2 |  └─EXCHANGE OUT DISTR                           |:EX10000|2       |9           |
|3 |    └─TOP-N SORT                                 |        |2       |7           |
|4 |      └─PX PARTITION ITERATOR                    |        |2       |7           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1      |2       |7           |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(2)
  4 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 3]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-2])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 3)
# 多分区查询: 快照数据
drop table if exists t1;
CREATE TABLE t1 (
c1 int primary key,
c2 sparsevector
) partition by hash(c1) partitions 3;
insert into t1 values(1, '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, '{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(10, '{11:1.1, 10:1.0, 12:1.2}');
create vector index idx1 on t1(c2) with (lib=vsag, type=sindi, distance=inner_product);
call dbms_stats.gather_table_stats('test','t1');
select * from t1 order by negative_inner_product(c2, '{}') approx limit 2;
c1	c2
select * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select * from t1 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
1	{1:0.1,2:0.2,3:0.3}
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select * from t1 where c1 <= 5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select /*+ opt_param('rowsets_enabled', 'false')*/ * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select /*+ parallel(8)*/ negative_inner_product(c2, '{3:1, 4:1}') from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
negative_inner_product(c2, '{3:1, 4:1}')
-0.7000000178813934
-0.7000000178813934
select /*+ index(t1 idx1)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0);
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
explain select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |2       |10          |
|1 |└─PX COORDINATOR MERGE SORT                       |        |2       |10          |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|2       |9           |
|3 |    └─TOP-N SORT                                  |        |2       |7           |
|4 |      └─PX PARTITION ITERATOR                     |        |2       |7           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |2       |7           |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(2)
  4 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 3]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-2])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 3)
explain select /*+ index(t1 idx1)*/ * from t1 where c1 > 10 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |1       |8           |
|1 |└─PX COORDINATOR MERGE SORT                       |        |1       |8           |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|1       |8           |
|3 |    └─TOP-N SORT                                  |        |1       |7           |
|4 |      └─PX PARTITION ITERATOR                     |        |1       |7           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |1       |7           |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(2)
  4 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 > 10]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-2])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(10 ; MAX)
explain select /*+ index(t1 primary)*/ * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
=====================================================================================
|ID|OPERATOR                                         |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |LIMIT                                            |        |2       |10          |
|1 |└─PX COORDINATOR MERGE SORT                      |        |2       |10          |
|2 |  └─EXCHANGE OUT DISTR                           |:EX10000|2       |9           |
|3 |    └─TOP-N SORT                                 |        |2       |7           |
|4 |      └─PX PARTITION ITERATOR                    |        |2       |7           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1      |2       |7           |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(2)
  4 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 3]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-2])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 3)
# 多分区查询: 快照数据+增量数据
drop table if exists t1;
alter system set vector_index_optimize_duty_time='[24:00:00, 24:00:00]';
CREATE TABLE t1 (
c1 int primary key,
c2 sparsevector
) partition by hash(c1) partitions 3;
insert into t1 values(1, '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, '{9:0.9, 10:1.0, 11:1.1}');
create vector index idx1 on t1(c2) with (lib=vsag, type=sindi, distance=inner_product);
call dbms_stats.gather_table_stats('test','t1');
insert into t1 values(10, '{11:1.1, 10:1.0, 12:1.2}');
select * from t1 order by negative_inner_product(c2, '{}') approx limit 2;
c1	c2
select * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select * from t1 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select * from t1 order by negative_inner_product(c2, '{10:1, 11:1}') approx limit 2;
c1	c2
9	{9:0.9,10:1,11:1.1}
10	{10:1,11:1.1,12:1.2}
select * from t1 order by negative_inner_product(c2, '{12:1, 13:1}') approx limit 2;
c1	c2
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
1	{1:0.1,2:0.2,3:0.3}
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{10:1, 11:1}') approx limit 2;
c1	c2
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{12:1, 13:1}') approx limit 2;
c1	c2
select * from t1 where c1 <= 5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select /*+ opt_param('rowsets_enabled', 'false')*/ * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select /*+ parallel(8)*/ negative_inner_product(c2, '{3:1, 4:1}') from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
negative_inner_product(c2, '{3:1, 4:1}')
-0.7000000178813934
-0.7000000178813934
select /*+ index(t1 idx1)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0);
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
explain select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |2       |10          |
|1 |└─PX COORDINATOR MERGE SORT                       |        |2       |10          |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|2       |9           |
|3 |    └─TOP-N SORT                                  |        |2       |7           |
|4 |      └─PX PARTITION ITERATOR                     |        |2       |7           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |2       |7           |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(2)
  4 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 3]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-2])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 3)
explain select /*+ index(t1 idx1)*/ * from t1 where c1 > 10 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |1       |8           |
|1 |└─PX COORDINATOR MERGE SORT                       |        |1       |8           |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|1       |8           |
|3 |    └─TOP-N SORT                                  |        |1       |7           |
|4 |      └─PX PARTITION ITERATOR                     |        |1       |7           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |1       |7           |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(2)
  4 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 > 10]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-2])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(10 ; MAX)
explain select /*+ index(t1 primary)*/ * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
=====================================================================================
|ID|OPERATOR                                         |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |LIMIT                                            |        |2       |10          |
|1 |└─PX COORDINATOR MERGE SORT                      |        |2       |10          |
|2 |  └─EXCHANGE OUT DISTR                           |:EX10000|2       |9           |
|3 |    └─TOP-N SORT                                 |        |2       |7           |
|4 |      └─PX PARTITION ITERATOR                    |        |2       |7           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1      |2       |7           |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(2)
  4 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 3]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-2])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 3)
drop table if exists t1;
create table t1(c1 int, c2 int, c3 sparsevector, primary key(c1), vector index idxv(c3) with (lib=vsag, type=sindi, distance=inner_product))
PARTITION BY RANGE (c1) (
PARTITION p0 VALUES LESS THAN (20),
PARTITION p1 VALUES LESS THAN (40),
PARTITION p2 VALUES LESS THAN (70),
PARTITION p3 VALUES LESS THAN (400),
PARTITION pMax VALUES LESS THAN MAXVALUE
);
create index idx1 on t1(c2);
insert into t1 values(1, 90,'{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, 98,'{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, 80,'{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, 75,'{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, 8,'{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, 9,'{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, 19,'{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, 39,'{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, 58,'{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(10, 62,'{11:1.1, 10:1.0, 12:1.2}');
insert into t1 values(21, 35,'{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(22, 41,'{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(23, 36,'{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(24, 1,'{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(25, 92,'{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(26, 53,'{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(27, 45,'{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(28, 7,'{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(29, 23,'{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(30, 74,'{11:1.1, 10:1.0, 12:1.2}');
insert into t1 values(41, 61,'{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(42, 35,'{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(43, 88,'{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(44, 54,'{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(45, 15,'{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(46, 83,'{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(47, 56,'{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(48, 19,'{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(49, 77,'{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(50, 23,'{11:1.1, 10:1.0, 12:1.2}');
insert into t1 values(71, 68,'{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(72, 37,'{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(73, 46,'{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(74, 79,'{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(75, 13,'{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(76, 29,'{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(77, 70,'{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(78, 38,'{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(79, 57,'{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(80, 48,'{11:1.1, 10:1.0, 12:1.2}');
insert into t1 values(401, 94,'{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(402, 62,'{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(403, 25,'{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(404, 58,'{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(405, 34,'{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(406, 73,'{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(407, 20,'{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(408, 76,'{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(409, 49,'{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(410, 57,'{11:1.1, 10:1.0, 12:1.2}');
select * from t1 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
402	62	{2:0.2,3:0.3,4:0.4}
72	37	{2:0.2,3:0.3,4:0.4}
403	25	{3:0.3,4:0.4,5:0.5}
73	46	{3:0.3,4:0.4,5:0.5}
23	36	{3:0.3,4:0.4,5:0.5}
22	41	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1 < 100 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
72	37	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
23	36	{3:0.3,4:0.4,5:0.5}
22	41	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
4	75	{4:0.4,5:0.5,6:0.6}
24	1	{4:0.4,5:0.5,6:0.6}
select /*+ opt_param('rowsets_enabled', 'false')*/ * from t1 where c1 < 100 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
72	37	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
23	36	{3:0.3,4:0.4,5:0.5}
22	41	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
4	75	{4:0.4,5:0.5,6:0.6}
24	1	{4:0.4,5:0.5,6:0.6}
select/*+opt_param('rowsets_enabled', 'false') index(t1 idx1)*/ * from t1 where c1 < 100 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
72	37	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
23	36	{3:0.3,4:0.4,5:0.5}
22	41	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
4	75	{4:0.4,5:0.5,6:0.6}
24	1	{4:0.4,5:0.5,6:0.6}
select/*+index(t1 idx1)*/ * from t1 where c1 < 100 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
72	37	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
23	36	{3:0.3,4:0.4,5:0.5}
22	41	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
4	75	{4:0.4,5:0.5,6:0.6}
24	1	{4:0.4,5:0.5,6:0.6}
select/*+opt_param('rowsets_enabled', 'false') index(t1 idxv)*/ * from t1 where c1 < 100 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
72	37	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
23	36	{3:0.3,4:0.4,5:0.5}
22	41	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
4	75	{4:0.4,5:0.5,6:0.6}
24	1	{4:0.4,5:0.5,6:0.6}
select/*+opt_param('rowsets_enabled', 'false') index(t1 idxv)*/ * from t1 where c1 < 100 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
72	37	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
23	36	{3:0.3,4:0.4,5:0.5}
22	41	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
4	75	{4:0.4,5:0.5,6:0.6}
24	1	{4:0.4,5:0.5,6:0.6}
explain select * from t1 where c1 < 100 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
=====================================================================================
|ID|OPERATOR                                         |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |LIMIT                                            |        |10      |30          |
|1 |└─PX COORDINATOR MERGE SORT                      |        |10      |30          |
|2 |  └─EXCHANGE OUT DISTR                           |:EX10000|10      |25          |
|3 |    └─TOP-N SORT                                 |        |10      |14          |
|4 |      └─PX PARTITION ITERATOR                    |        |40      |12          |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1      |40      |12          |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 100]), rowset=256
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p[0-3])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 100)
explain select/*+index(t1 idx1)*/ * from t1 where c1 < 100 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
=====================================================================================
|ID|OPERATOR                                         |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |LIMIT                                            |        |4       |37          |
|1 |└─PX COORDINATOR MERGE SORT                      |        |4       |37          |
|2 |  └─EXCHANGE OUT DISTR                           |:EX10000|4       |35          |
|3 |    └─TOP-N SORT                                 |        |4       |31          |
|4 |      └─PX PARTITION ITERATOR                    |        |4       |30          |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1(idx1)|4       |30          |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 100]), rowset=16
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p[0-3])
      is_index_back=true, is_global_index=false, filter_before_indexback[true],
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
explain select/*+index(t1 idxv)*/ * from t1 where c1 < 100 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |10      |30          |
|1 |└─PX COORDINATOR MERGE SORT                       |        |10      |30          |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|10      |25          |
|3 |    └─TOP-N SORT                                  |        |10      |14          |
|4 |      └─PX PARTITION ITERATOR                     |        |40      |12          |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |40      |12          |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 100]), rowset=256
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p[0-3])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 100)
select * from t1 where c1 < 10 or c1 > 40 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
402	62	{2:0.2,3:0.3,4:0.4}
403	25	{3:0.3,4:0.4,5:0.5}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
72	37	{2:0.2,3:0.3,4:0.4}
4	75	{4:0.4,5:0.5,6:0.6}
44	54	{4:0.4,5:0.5,6:0.6}
select/*+index(t1 idx1)*/  * from t1 where c1 < 10 or c1 > 40 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
402	62	{2:0.2,3:0.3,4:0.4}
403	25	{3:0.3,4:0.4,5:0.5}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
72	37	{2:0.2,3:0.3,4:0.4}
4	75	{4:0.4,5:0.5,6:0.6}
44	54	{4:0.4,5:0.5,6:0.6}
select/*+index(t1 idxv)*/ * from t1 where c1 < 10 or c1 > 40  order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
402	62	{2:0.2,3:0.3,4:0.4}
403	25	{3:0.3,4:0.4,5:0.5}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
72	37	{2:0.2,3:0.3,4:0.4}
4	75	{4:0.4,5:0.5,6:0.6}
44	54	{4:0.4,5:0.5,6:0.6}
explain select * from t1 where c1 < 10 or c1 > 40 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |10      |38          |
|1 |└─PX COORDINATOR MERGE SORT                       |        |10      |38          |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|10      |33          |
|3 |    └─TOP-N SORT                                  |        |10      |22          |
|4 |      └─PX PARTITION ITERATOR                     |        |39      |20          |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |39      |20          |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 10 OR t1.c1 > 40]), rowset=256
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p0, p[2-4])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 10), (40 ; MAX)
explain select/*+index(t1 idx1)*/  * from t1 where c1 < 10 or c1 > 40 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
=====================================================================================
|ID|OPERATOR                                         |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |LIMIT                                            |        |8       |54          |
|1 |└─PX COORDINATOR MERGE SORT                      |        |8       |54          |
|2 |  └─EXCHANGE OUT DISTR                           |:EX10000|8       |50          |
|3 |    └─TOP-N SORT                                 |        |8       |42          |
|4 |      └─PX PARTITION ITERATOR                    |        |8       |41          |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1(idx1)|8       |41          |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 10 OR t1.c1 > 40]), rowset=16
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p0, p[2-4])
      is_index_back=true, is_global_index=false, filter_before_indexback[true],
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
explain select/*+index(t1 idxv)*/ * from t1 where c1 < 10 or c1 > 40  order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |10      |38          |
|1 |└─PX COORDINATOR MERGE SORT                       |        |10      |38          |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|10      |33          |
|3 |    └─TOP-N SORT                                  |        |10      |22          |
|4 |      └─PX PARTITION ITERATOR                     |        |39      |20          |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |39      |20          |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 10 OR t1.c1 > 40]), rowset=256
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p0, p[2-4])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.c1]), range(NULL ; 10), (40 ; MAX)
select * from t1 where c2 < 80 and c2 > 20 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
23	36	{3:0.3,4:0.4,5:0.5}
403	25	{3:0.3,4:0.4,5:0.5}
22	41	{2:0.2,3:0.3,4:0.4}
402	62	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
72	37	{2:0.2,3:0.3,4:0.4}
42	35	{2:0.2,3:0.3,4:0.4}
4	75	{4:0.4,5:0.5,6:0.6}
74	79	{4:0.4,5:0.5,6:0.6}
44	54	{4:0.4,5:0.5,6:0.6}
select/*+index(t1 idxv)*/ * from t1 where c1 < 80 and c1 > 20  order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
23	36	{3:0.3,4:0.4,5:0.5}
22	41	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
72	37	{2:0.2,3:0.3,4:0.4}
74	79	{4:0.4,5:0.5,6:0.6}
44	54	{4:0.4,5:0.5,6:0.6}
24	1	{4:0.4,5:0.5,6:0.6}
41	61	{1:0.1,2:0.2,3:0.3}
select/*+index(t1 primary)*/ * from t1 where c1 < 80 and c1 > 20  order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
23	36	{3:0.3,4:0.4,5:0.5}
22	41	{2:0.2,3:0.3,4:0.4}
73	46	{3:0.3,4:0.4,5:0.5}
72	37	{2:0.2,3:0.3,4:0.4}
74	79	{4:0.4,5:0.5,6:0.6}
44	54	{4:0.4,5:0.5,6:0.6}
24	1	{4:0.4,5:0.5,6:0.6}
41	61	{1:0.1,2:0.2,3:0.3}
explain select * from t1 where c2 < 80 and c2 > 20 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
=====================================================================================
|ID|OPERATOR                                         |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |LIMIT                                            |        |10      |128         |
|1 |└─PX COORDINATOR MERGE SORT                      |        |10      |128         |
|2 |  └─EXCHANGE OUT DISTR                           |:EX10000|10      |123         |
|3 |    └─TOP-N SORT                                 |        |10      |112         |
|4 |      └─PX PARTITION ITERATOR                    |        |34      |109         |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1(idx1)|34      |109         |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c2 < 80], [t1.c2 > 20]), rowset=256
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p[0-4])
      is_index_back=true, is_global_index=false, filter_before_indexback[true,true],
      range_key([t1.c2], [t1.c1]), range(20,MAX ; 80,MIN)
explain select/*+index(t1 idxv)*/ * from t1 where c1 < 80 and c1 > 20  order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |10      |27          |
|1 |└─PX COORDINATOR MERGE SORT                       |        |10      |27          |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|10      |22          |
|3 |    └─TOP-N SORT                                  |        |10      |11          |
|4 |      └─PX PARTITION ITERATOR                     |        |29      |9           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |29      |9           |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 80], [t1.c1 > 20]), rowset=256
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p[1-3])
      is_index_back=true, is_global_index=false, filter_before_indexback[false,false],
      range_key([t1.c1]), range(20 ; 80)
explain select/*+index(t1 primary)*/ * from t1 where c1 < 80 and c1 > 20  order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
=====================================================================================
|ID|OPERATOR                                         |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |LIMIT                                            |        |10      |27          |
|1 |└─PX COORDINATOR MERGE SORT                      |        |10      |27          |
|2 |  └─EXCHANGE OUT DISTR                           |:EX10000|10      |22          |
|3 |    └─TOP-N SORT                                 |        |10      |11          |
|4 |      └─PX PARTITION ITERATOR                    |        |29      |9           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1      |29      |9           |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=256
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 80], [t1.c1 > 20]), rowset=256
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p[1-3])
      is_index_back=true, is_global_index=false, filter_before_indexback[false,false],
      range_key([t1.c1]), range(20 ; 80)
select * from t1 where c1 < 80 and c2 > 20 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
73	46	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
72	37	{2:0.2,3:0.3,4:0.4}
22	41	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
23	36	{3:0.3,4:0.4,5:0.5}
4	75	{4:0.4,5:0.5,6:0.6}
44	54	{4:0.4,5:0.5,6:0.6}
select/*+index(t1 idxv)*/ * from t1 where c1 < 80 and c2 > 20 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
73	46	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
72	37	{2:0.2,3:0.3,4:0.4}
22	41	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
23	36	{3:0.3,4:0.4,5:0.5}
4	75	{4:0.4,5:0.5,6:0.6}
44	54	{4:0.4,5:0.5,6:0.6}
select/*+index(t1 idx1)*/ * from t1 where c1 < 80 and c2 > 20 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
c1	c2	c3
73	46	{3:0.3,4:0.4,5:0.5}
2	98	{2:0.2,3:0.3,4:0.4}
72	37	{2:0.2,3:0.3,4:0.4}
22	41	{2:0.2,3:0.3,4:0.4}
3	80	{3:0.3,4:0.4,5:0.5}
43	88	{3:0.3,4:0.4,5:0.5}
42	35	{2:0.2,3:0.3,4:0.4}
23	36	{3:0.3,4:0.4,5:0.5}
4	75	{4:0.4,5:0.5,6:0.6}
44	54	{4:0.4,5:0.5,6:0.6}
explain select/*+index(t1 idx1)*/ * from t1 where c1 < 80 and c2 > 20 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
=====================================================================================
|ID|OPERATOR                                         |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |LIMIT                                            |        |10      |63          |
|1 |└─PX COORDINATOR MERGE SORT                      |        |10      |63          |
|2 |  └─EXCHANGE OUT DISTR                           |:EX10000|10      |58          |
|3 |    └─TOP-N SORT                                 |        |10      |47          |
|4 |      └─PX PARTITION ITERATOR                    |        |11      |46          |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1(idx1)|11      |46          |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 80], [t1.c2 > 20]), rowset=16
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p[0-3])
      is_index_back=true, is_global_index=false, filter_before_indexback[true,true],
      range_key([t1.c2], [t1.c1]), range(20,MAX ; MAX,MAX)
explain select/*+index(t1 idxv)*/ * from t1 where c1 < 80 and c2 > 20 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |10      |29          |
|1 |└─PX COORDINATOR MERGE SORT                       |        |10      |29          |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|10      |24          |
|3 |    └─TOP-N SORT                                  |        |10      |13          |
|4 |      └─PX PARTITION ITERATOR                     |        |13      |11          |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |13      |11          |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 80], [t1.c2 > 20]), rowset=16
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p[0-3])
      is_index_back=true, is_global_index=false, filter_before_indexback[false,false],
      range_key([t1.c1]), range(NULL ; 80)
explain select/*+index(t1 idx1)*/ * from t1 where c1 < 80 and c2 > 20 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 10;
Query Plan
=====================================================================================
|ID|OPERATOR                                         |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |LIMIT                                            |        |10      |63          |
|1 |└─PX COORDINATOR MERGE SORT                      |        |10      |63          |
|2 |  └─EXCHANGE OUT DISTR                           |:EX10000|10      |58          |
|3 |    └─TOP-N SORT                                 |        |10      |47          |
|4 |      └─PX PARTITION ITERATOR                    |        |11      |46          |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1(idx1)|11      |46          |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [t1.c3], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(10)
  4 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c3], [t1.c2], [negative_inner_product(t1.c3, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 80], [t1.c2 > 20]), rowset=16
      access([t1.c1], [t1.c3], [t1.c2]), partitions(p[0-3])
      is_index_back=true, is_global_index=false, filter_before_indexback[true,true],
      range_key([t1.c2], [t1.c1]), range(20,MAX ; MAX,MAX)
drop table if exists t1;
create table t1(c1 int, c2 int, c3 int, v sparsevector, primary key(c1), vector index idx3(v) with (lib=vsag, type=sindi, distance=inner_product));
insert into t1 values(1, 1, 10, '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, 2, 9, '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, 3, 8, '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, 4, 7, '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, 5, 6, '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, 6, 5, '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, 7, 4, '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, 8, 3, '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, 9, 2, '{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(10, 10, 1, '{11:1.1, 10:1.0, 12:1.2}');
create index idx1 on t1(c2);
create index idx2 on t1(c3);
select * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select /*+ opt_param('rowsets_enabled', 'false')*/ * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select /*+index(t1 primary) */ * from t1 where c1 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
3	3	8	{3:0.3,4:0.4,5:0.5}
2	2	9	{2:0.2,3:0.3,4:0.4}
4	4	7	{4:0.4,5:0.5,6:0.6}
1	1	10	{1:0.1,2:0.2,3:0.3}
select /*+index(t1 idx1) */ * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select /*+index(t1 idx2) */ * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select /*+index(t1 idx3) */ * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select * from t1 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
3	3	8	{3:0.3,4:0.4,5:0.5}
2	2	9	{2:0.2,3:0.3,4:0.4}
4	4	7	{4:0.4,5:0.5,6:0.6}
1	1	10	{1:0.1,2:0.2,3:0.3}
explain select * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
Query Plan
===========================================================================
|ID|OPERATOR                               |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1(idx1)|2       |17          |
===========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.v]), filter([t1.c2 > 5], [t1.c3 < 6]), rowset=16
      access([t1.c1], [t1.v], [t1.c2], [t1.c3]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[true,false],
      range_key([t1.c2], [t1.c1]), range(5,MAX ; MAX,MAX)
explain select /*+index(t1 idx1) */ * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
Query Plan
===========================================================================
|ID|OPERATOR                               |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1(idx1)|2       |17          |
===========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.v]), filter([t1.c2 > 5], [t1.c3 < 6]), rowset=16
      access([t1.c1], [t1.v], [t1.c2], [t1.c3]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[true,false],
      range_key([t1.c2], [t1.c1]), range(5,MAX ; MAX,MAX)
explain select /*+index(t1 idx2) */ * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
Query Plan
===========================================================================
|ID|OPERATOR                               |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (PRE-FILTER)|t1(idx2)|2       |17          |
===========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.v]), filter([t1.c2 > 5], [t1.c3 < 6]), rowset=16
      access([t1.c1], [t1.v], [t1.c2], [t1.c3]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false,true],
      range_key([t1.c3], [t1.c1]), range(NULL,MAX ; 6,MIN)
explain select /*+index(t1 idx3) */ * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
Query Plan
=================================================================================
|ID|OPERATOR                                |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------
|0 |VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1(idx1,idx3)|2       |17          |
=================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.v]), filter([t1.c2 > 5], [t1.c3 < 6]), rowset=16
      access([t1.c1], [t1.v], [t1.c2], [t1.c3]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[true,false],
      range_key([t1.c2], [t1.c1]), range(5,MAX ; MAX,MAX)
explain select * from t1 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
Query Plan
=====================================================
|ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |VECTOR INDEX SCAN|t1(idx3)|10      |31          |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.v]), filter(nil), rowset=16
      access([t1.c1], [t1.v], [t1.c2], [t1.c3]), partitions(p0)
      is_index_back=true, is_global_index=false,
      range_key([t1.__vid_0], [t1.__type_0_0]), range(MIN,MIN ; MAX,MAX)always true
drop table if exists t1;
create table t1(c1 int, c2 int, c3 int, v sparsevector, primary key(c1), vector index idx3(v) with (lib=vsag, type=sindi, distance=inner_product)) WITH COLUMN GROUP (each column);
insert into t1 values(1, 1, 10, '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, 2, 9, '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, 3, 8, '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, 4, 7, '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, 5, 6, '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, 6, 5, '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, 7, 4, '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, 8, 3, '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, 9, 2, '{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(10, 10, 1, '{11:1.1, 10:1.0, 12:1.2}');
create index idx1 on t1(c2);
select * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select /*+index(t1 idx1) */ * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select /*+index(t1 idx3) */ * from t1 where c2 > 5 and c3 < 6 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select * from t1 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
3	3	8	{3:0.3,4:0.4,5:0.5}
2	2	9	{2:0.2,3:0.3,4:0.4}
4	4	7	{4:0.4,5:0.5,6:0.6}
1	1	10	{1:0.1,2:0.2,3:0.3}
drop table if exists t1;
drop table if exists t2;
create table t1(c1 int, c2 int, c3 int, v sparsevector, primary key(c1), vector index idx3(v) with (lib=vsag, type=sindi, distance=inner_product));
insert into t1 values(1, 1, 10, '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, 2, 9, '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, 3, 8, '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, 4, 7, '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, 5, 6, '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, 6, 5, '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, 7, 4, '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, 8, 3, '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, 9, 2, '{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(10, 10, 1, '{11:1.1, 10:1.0, 12:1.2}');
create index idx1 on t1(c2);
create table t2(c1 int, c2 int, c3 int, v sparsevector, primary key(c1), vector index idx3(v) with (lib=vsag, type=sindi, distance=inner_product));
insert into t2 values(1, 1, 10, '{1:0.1,2:0.2, 3:0.3}');
insert into t2 values(2, 2, 9, '{3:0.3, 2:0.2, 4:0.4}');
insert into t2 values(3, 3, 8, '{3:0.3, 4:0.4, 5:0.5}');
insert into t2 values(4, 4, 7, '{5:0.5, 4:0.4, 6:0.6}');
insert into t2 values(5, 5, 6, '{5:0.5, 6:0.6, 7:0.7}');
insert into t2 values(6, 6, 5, '{7:0.7, 6:0.6, 8:0.8}');
insert into t2 values(7, 7, 4, '{7:0.7, 8:0.8, 9:0.9}');
insert into t2 values(8, 8, 3, '{9:0.9, 8:0.8, 10:1.0}');
insert into t2 values(9, 9, 2, '{9:0.9, 10:1.0, 11:1.1}');
insert into t2 values(10, 10, 1, '{11:1.1, 10:1.0, 12:1.2}');
select * from t1 where c2 > 5
order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select * from t1 where c2 > 5 GROUP BY c1
order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select * from t1 where c2 > 5 GROUP BY c1 having c1 < 8
order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select *, CASE
WHEN c1 < 6 THEN 'first halp'
    ELSE 'second half'
  END AS pri_category
from t1 where c2 > 5
order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 8;
c1	c2	c3	v	pri_category
select * from t1 a join t2 b on a.c1=b.c1 order by negative_inner_product(a.v, '{3:1, 4:1}') approximate limit 3;
c1	c2	c3	v	c1	c2	c3	v
3	3	8	{3:0.3,4:0.4,5:0.5}	3	3	8	{3:0.3,4:0.4,5:0.5}
2	2	9	{2:0.2,3:0.3,4:0.4}	2	2	9	{2:0.2,3:0.3,4:0.4}
4	4	7	{4:0.4,5:0.5,6:0.6}	4	4	7	{4:0.4,5:0.5,6:0.6}
select count(*) from
(select * from t1 where c2 - 1 > 5 order by negative_inner_product(v, '{3:1, 4:1}')
APPROXIMATE limit 5) as tmp1,
(select * from t2 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5)
as tmp2 where tmp1.c1=tmp2.c1;
count(*)
0
select * from t1 where c2 != 5 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
3	3	8	{3:0.3,4:0.4,5:0.5}
2	2	9	{2:0.2,3:0.3,4:0.4}
4	4	7	{4:0.4,5:0.5,6:0.6}
1	1	10	{1:0.1,2:0.2,3:0.3}
select * from t1 FORCE INDEX (idx3) where c2 > 5 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select /*+read_consistency(weak) */ * from t1 where c2 > 5 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
select /*+ ENABLE_PARALLEL_DML parallel(256) */ * from t1 where c2 > 5 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
WITH query_result AS (
select * from t1 where c2 > 5
order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5
)
SELECT c1 FROM query_result;
c1
select DISTINCT c3 from t1 where c2 > 2 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c3
8
7
select c1, t1.c2 as c9 from t1 where c2 > 2 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c9
3	3
4	4
select * from t1 where c2 > 5 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 2 for update;
ERROR 0A000: FOR UPDATE with APPROXIMATE vector search is not supported
select * from t1 order by negative_inner_product(v, '{3:1, 4:1}') APPROXIMATE limit 5;
c1	c2	c3	v
3	3	8	{3:0.3,4:0.4,5:0.5}
2	2	9	{2:0.2,3:0.3,4:0.4}
4	4	7	{4:0.4,5:0.5,6:0.6}
1	1	10	{1:0.1,2:0.2,3:0.3}
drop table if exists t1;
drop table if exists t2;
create table t1(c1 int, c2 vector(10), c3 sparsevector, primary key(c1), vector index idx1(c2) with (distance=l2, type=hnsw, lib=vsag), vector index idx2(c3) with (distance=inner_product, type=sindi, lib=vsag));
insert into t1 values(1, '[0.203846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]', '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, '[0.735541,0.670776,0.903237,0.447223,0.232028,0.659316,0.765661,0.226980,0.579658,0.933939]', '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, '[0.327936,0.048756,0.084670,0.389642,0.970982,0.370915,0.181664,0.940780,0.013905,0.628127]', '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, '[0.148869,0.878546,0.028024,0.326642,0.044912,0.144034,0.717580,0.442633,0.637534,0.633993]', '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, '[0.334970,0.857377,0.886132,0.668270,0.983913,0.418145,0.208459,0.190118,0.959676,0.796483]', '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, '[0.117582,0.302352,0.471198,0.248725,0.315868,0.717533,0.028496,0.710370,0.007130,0.710913]', '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, '[0.551185,0.231134,0.075354,0.230557,0.248149,0.383390,0.483179,0.238120,0.289662,0.970101]', '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, '[0.185221,0.315131,0.558301,0.543172,0.335010,0.556101,0.595842,0.168794,0.567442,0.062338]', '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, '[0.928764,0.254038,0.272721,0.648755,0.966464,0.200054,0.093298,0.901419,0.676738,0.122339]', '{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(10, '[0.345999,0.254102,0.950869,0.275233,0.844568,0.215723,0.302821,0.563644,0.811224,0.175574]', '{11:1.1, 10:1.0, 12:1.2}');
select * from t1 order by l2_distance(c2, [0.712338,0.603321,0.133444,0.428146,0.876387,0.763293,0.408760,0.765300,0.560072,0.900498]) APPROXIMATE limit 2;
c1	c2	c3
3	[0.327936,0.048756,0.08467,0.389642,0.970982,0.370915,0.181664,0.94078,0.013905,0.628127]	{3:0.3,4:0.4,5:0.5}
7	[0.551185,0.231134,0.075354,0.230557,0.248149,0.38339,0.483179,0.23812,0.289662,0.970101]	{7:0.7,8:0.8,9:0.9}
select * from t1 where c1>5 order by l2_distance(c2, [0.712338,0.603321,0.133444,0.428146,0.876387,0.763293,0.408760,0.765300,0.560072,0.900498]) APPROXIMATE limit 2;
c1	c2	c3
7	[0.551185,0.231134,0.075354,0.230557,0.248149,0.38339,0.483179,0.23812,0.289662,0.970101]	{7:0.7,8:0.8,9:0.9}
9	[0.928764,0.254038,0.272721,0.648755,0.966464,0.200054,0.093298,0.901419,0.676738,0.122339]	{9:0.9,10:1,11:1.1}
select * from t1 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 2;
c1	c2	c3
3	[0.327936,0.048756,0.08467,0.389642,0.970982,0.370915,0.181664,0.94078,0.013905,0.628127]	{3:0.3,4:0.4,5:0.5}
2	[0.735541,0.670776,0.903237,0.447223,0.232028,0.659316,0.765661,0.22698,0.579658,0.933939]	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1 > 5 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 2;
c1	c2	c3
drop table if exists t1;
create table t1(c1 int, c2 vector(10), c3 sparsevector, primary key(c1), vector index idx1(c2) with (distance=l2, type=ivf_flat, lib=ob, nlist=2, sample_per_nlist=3), vector index idx2(c3) with (distance=inner_product, type=sindi, lib=vsag));
insert into t1 values(1, '[0.203846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]', '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, '[0.735541,0.670776,0.903237,0.447223,0.232028,0.659316,0.765661,0.226980,0.579658,0.933939]', '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, '[0.327936,0.048756,0.084670,0.389642,0.970982,0.370915,0.181664,0.940780,0.013905,0.628127]', '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, '[0.148869,0.878546,0.028024,0.326642,0.044912,0.144034,0.717580,0.442633,0.637534,0.633993]', '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, '[0.334970,0.857377,0.886132,0.668270,0.983913,0.418145,0.208459,0.190118,0.959676,0.796483]', '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, '[0.117582,0.302352,0.471198,0.248725,0.315868,0.717533,0.028496,0.710370,0.007130,0.710913]', '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, '[0.551185,0.231134,0.075354,0.230557,0.248149,0.383390,0.483179,0.238120,0.289662,0.970101]', '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, '[0.185221,0.315131,0.558301,0.543172,0.335010,0.556101,0.595842,0.168794,0.567442,0.062338]', '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, '[0.928764,0.254038,0.272721,0.648755,0.966464,0.200054,0.093298,0.901419,0.676738,0.122339]', '{9:0.9, 10:1.0, 11:1.1}');
insert into t1 values(10, '[0.345999,0.254102,0.950869,0.275233,0.844568,0.215723,0.302821,0.563644,0.811224,0.175574]', '{11:1.1, 10:1.0, 12:1.2}');
select * from t1 order by l2_distance(c2, [0.712338,0.603321,0.133444,0.428146,0.876387,0.763293,0.408760,0.765300,0.560072,0.900498]) APPROXIMATE limit 2;
c1	c2	c3
3	[0.327936,0.048756,0.08467,0.389642,0.970982,0.370915,0.181664,0.94078,0.013905,0.628127]	{3:0.3,4:0.4,5:0.5}
7	[0.551185,0.231134,0.075354,0.230557,0.248149,0.38339,0.483179,0.23812,0.289662,0.970101]	{7:0.7,8:0.8,9:0.9}
select * from t1 where c1>5 order by l2_distance(c2, [0.712338,0.603321,0.133444,0.428146,0.876387,0.763293,0.408760,0.765300,0.560072,0.900498]) APPROXIMATE limit 2;
c1	c2	c3
7	[0.551185,0.231134,0.075354,0.230557,0.248149,0.38339,0.483179,0.23812,0.289662,0.970101]	{7:0.7,8:0.8,9:0.9}
9	[0.928764,0.254038,0.272721,0.648755,0.966464,0.200054,0.093298,0.901419,0.676738,0.122339]	{9:0.9,10:1,11:1.1}
select * from t1 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 2;
c1	c2	c3
3	[0.327936,0.048756,0.08467,0.389642,0.970982,0.370915,0.181664,0.94078,0.013905,0.628127]	{3:0.3,4:0.4,5:0.5}
2	[0.735541,0.670776,0.903237,0.447223,0.232028,0.659316,0.765661,0.22698,0.579658,0.933939]	{2:0.2,3:0.3,4:0.4}
select * from t1 where c1 > 5 order by negative_inner_product(c3, '{3:1, 4:1}') APPROXIMATE limit 2;
c1	c2	c3
drop table if exists t1;
======= 无主键 =========
alter system set vector_index_optimize_duty_time='[24:00:00, 24:00:00]';
CREATE TABLE t1 (c1 int, c2 sparsevector) partition by hash(c1) partitions 3;
insert into t1 values(1, '{1:0.1,2:0.2, 3:0.3}');
insert into t1 values(2, '{3:0.3, 2:0.2, 4:0.4}');
insert into t1 values(3, '{3:0.3, 4:0.4, 5:0.5}');
insert into t1 values(4, '{5:0.5, 4:0.4, 6:0.6}');
insert into t1 values(5, '{5:0.5, 6:0.6, 7:0.7}');
insert into t1 values(6, '{7:0.7, 6:0.6, 8:0.8}');
insert into t1 values(7, '{7:0.7, 8:0.8, 9:0.9}');
insert into t1 values(8, '{9:0.9, 8:0.8, 10:1.0}');
insert into t1 values(9, '{9:0.9, 10:1.0, 11:1.1}');
create vector index idx1 on t1(c2) with (lib=vsag, type=sindi, distance=inner_product);
insert into t1 values(10, '{11:1.1, 10:1.0, 12:1.2}');
call dbms_stats.gather_table_stats('test','t1');
select * from t1 order by negative_inner_product(c2, '{}') approx limit 2;
c1	c2
select * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select * from t1 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select * from t1 order by negative_inner_product(c2, '{10:1, 11:1}') approx limit 2;
c1	c2
9	{9:0.9,10:1,11:1.1}
10	{10:1,11:1.1,12:1.2}
select * from t1 order by negative_inner_product(c2, '{12:1, 13:1}') approx limit 2;
c1	c2
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
1	{1:0.1,2:0.2,3:0.3}
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{13:1, 14:1}') approx limit 2;
c1	c2
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{10:1, 11:1}') approx limit 2;
c1	c2
select * from t1 where c1 < 3 order by negative_inner_product(c2, '{12:1, 13:1}') approx limit 2;
c1	c2
select * from t1 where c1 <= 5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select /*+ opt_param('rowsets_enabled', 'false')*/ * from t1 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select /*+ parallel(8)*/ negative_inner_product(c2, '{3:1, 4:1}') from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
negative_inner_product(c2, '{3:1, 4:1}')
-0.7000000178813934
-0.7000000178813934
select /*+ index(t1 idx1)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
select * from t1 where c1<=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2 parameters(refine_k=1.0, drop_ratio_search=0);
c1	c2
2	{2:0.2,3:0.3,4:0.4}
3	{3:0.3,4:0.4,5:0.5}
explain select * from t1 where c1 < 3 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |2       |9           |
|1 |└─PX COORDINATOR MERGE SORT                       |        |2       |9           |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|2       |9           |
|3 |    └─TOP-N SORT                                  |        |2       |7           |
|4 |      └─PX PARTITION ITERATOR                     |        |2       |7           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |2       |7           |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(2)
  4 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 < 3]), rowset=16
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p[0-2])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
explain select /*+ index(t1 idx1)*/ * from t1 where c1 <=5 order by negative_inner_product(c2, '{3:1, 4:1}') approx limit 2;
Query Plan
======================================================================================
|ID|OPERATOR                                          |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------------
|0 |LIMIT                                             |        |2       |10          |
|1 |└─PX COORDINATOR MERGE SORT                       |        |2       |10          |
|2 |  └─EXCHANGE OUT DISTR                            |:EX10000|2       |9           |
|3 |    └─TOP-N SORT                                  |        |2       |8           |
|4 |      └─PX PARTITION ITERATOR                     |        |5       |7           |
|5 |        └─VECTOR INDEX ADAPTIVE SCAN (POST-FILTER)|t1      |5       |7           |
======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC])
  2 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      sort_keys([negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1))), ASC]), topn(2)
  4 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter(nil), rowset=16
      force partition granule
  5 - output([t1.c1], [t1.c2], [negative_inner_product(t1.c2, cast('{3:1, 4:1}', ARRAY(18, -1)))]), filter([t1.c1 <= 5]), rowset=16
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p[0-2])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
drop table if exists t1;
