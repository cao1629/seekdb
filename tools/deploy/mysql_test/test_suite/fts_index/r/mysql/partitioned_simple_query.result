drop database if exists fts;
create database fts;
use fts;
create table t_ir_single_column(
seq int PRIMARY KEY,
digest varchar(512),
detail varchar(4096),
fulltext index i1(detail)) partition by hash(seq) partitions 2;
create table t_dim_table(
seq int,
log varchar(1024));
insert into t_ir_single_column (seq, digest, detail) values
(0, "Gerard Salton", "Gerard A. Gerry Salton (8 March 1927 – 28 August 1995) was a professor of Computer Science at Cornell University. Salton was perhaps the leading computer scientist working in the field of information retrieval during his time, and the father of Information Retrieval"),
(1, "Edgar F. Codd", "Edgar Frank Ted Codd (19 August 1923 – 18 April 2003) was an English computer scientist who, while working for IBM, invented the relational model for database management, the theoretical basis for relational databases and relational database management systems. "),
(2, "Michael Stonebraker", "Michael Ralph Stonebraker (born October 11, 1943[6]) is a computer scientist specializing in database systems. Through a series of academic prototypes and commercial startups, Stonebraker's research and products are central to many relational databases. "),
(3, "Geoffrey Hinton", "Geoffrey Everest Hinton CC FRS FRSC (born 6 December 1947) is a British-Canadian computer scientist and cognitive psychologist, most noted for his work on artificial neural networks."),
(4, "Yann LeCun", "Yann André LeCun[1] (born 8 July 1960) is a Turing Award winning French computer scientist working primarily in the fields of machine learning, computer vision, mobile robotics and computational neuroscience."),
(5, "Ken Thompson", "Kenneth Lane Thompson (born February 4, 1943) is an American pioneer of computer science. Thompson worked at Bell Labs for most of his career where he designed and implemented the original Unix operating system. "),
(6, "Gordon Plotkin", "Gordon David Plotkin, FRS FRSE MAE (born 9 September 1946) is a theoretical computer scientist in the School of Informatics at the University of Edinburgh. Plotkin is probably best known for his introduction of structural operational semantics (SOS) and his work on denotational semantics."),
(7, "Leslie Lamport", "Leslie B. Lamport (born February 7, 1941) is an American computer scientist and mathematician. Lamport is best known for his seminal work in distributed systems, and as the initial developer of the document preparation system LaTeX");
insert into t_dim_table (seq, log) values
(1, "Codd log"),
(3, "Hinton log"),
(5, "Ken log"),
(7, "Lamport log"),
(9, "someone's log");
result_format: 4
select seq, digest from t_ir_single_column partition(p0);
+-----+---------------------+
| seq | digest              |
+-----+---------------------+
|   0 | Gerard Salton       |
|   2 | Michael Stonebraker |
|   4 | Yann LeCun          |
|   6 | Gordon Plotkin      |
+-----+---------------------+

select seq, digest from t_ir_single_column partition(p1);
+-----+-----------------+
| seq | digest          |
+-----+-----------------+
|   1 | Edgar F. Codd   |
|   3 | Geoffrey Hinton |
|   5 | Ken Thompson    |
|   7 | Leslie Lamport  |
+-----+-----------------+

set ob_enable_index_direct_select = 'ON';

explain select digest, detail from t_ir_single_column where match (detail) against ("database");
Query Plan
=============================================================================
|ID|OPERATOR                   |NAME                  |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |                      |2       |42          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000              |2       |39          |
|2 |  └─SORT                   |                      |2       |32          |
|3 |    └─PX PARTITION ITERATOR|                      |2       |32          |
|4 |      └─TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|2       |32          |
=============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_ir_single_column.digest, t_ir_single_column.detail)]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('database'), DESC])
  1 - output([MATCH(t_ir_single_column.detail) AGAINST('database')], [INTERNAL_FUNCTION(t_ir_single_column.digest, t_ir_single_column.detail)]), filter(nil), rowset=16
      dop=1
  2 - output([MATCH(t_ir_single_column.detail) AGAINST('database')], [t_ir_single_column.detail], [t_ir_single_column.digest]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('database'), DESC])
  3 - output([t_ir_single_column.detail], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('database')]), filter(nil), rowset=16
      force partition granule
  4 - output([t_ir_single_column.detail], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('database')]), filter(nil), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.detail], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('database')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('database'))
explain /*+ use_das(t_ir_single_column) */ select digest, detail from t_ir_single_column where match (detail) against ("database");
Query Plan
=============================================================================
|ID|OPERATOR                   |NAME                  |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |                      |2       |42          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000              |2       |39          |
|2 |  └─SORT                   |                      |2       |32          |
|3 |    └─PX PARTITION ITERATOR|                      |2       |32          |
|4 |      └─TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|2       |32          |
=============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_ir_single_column.digest, t_ir_single_column.detail)]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('database'), DESC])
  1 - output([MATCH(t_ir_single_column.detail) AGAINST('database')], [INTERNAL_FUNCTION(t_ir_single_column.digest, t_ir_single_column.detail)]), filter(nil), rowset=16
      dop=1
  2 - output([MATCH(t_ir_single_column.detail) AGAINST('database')], [t_ir_single_column.detail], [t_ir_single_column.digest]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('database'), DESC])
  3 - output([t_ir_single_column.detail], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('database')]), filter(nil), rowset=16
      force partition granule
  4 - output([t_ir_single_column.detail], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('database')]), filter(nil), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.detail], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('database')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('database'))

select digest, detail from t_ir_single_column where match (detail) against ("distributed database");
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| digest              | detail                                                                                                                                                                                                                                                                   |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Edgar F. Codd       | Edgar Frank Ted Codd (19 August 1923 – 18 April 2003) was an English computer scientist who, while working for IBM, invented the relational model for database management, the theoretical basis for relational databases and relational database management systems.    |
| Leslie Lamport      | Leslie B. Lamport (born February 7, 1941) is an American computer scientist and mathematician. Lamport is best known for his seminal work in distributed systems, and as the initial developer of the document preparation system LaTeX                                  |
| Michael Stonebraker | Michael Ralph Stonebraker (born October 11, 1943[6]) is a computer scientist specializing in database systems. Through a series of academic prototypes and commercial startups, Stonebraker's research and products are central to many relational databases.            |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
select /*+ use_das(t_ir_single_column) */ digest, detail from t_ir_single_column where match (detail) against ("distributed database");
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| digest              | detail                                                                                                                                                                                                                                                                   |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Edgar F. Codd       | Edgar Frank Ted Codd (19 August 1923 – 18 April 2003) was an English computer scientist who, while working for IBM, invented the relational model for database management, the theoretical basis for relational databases and relational database management systems.    |
| Leslie Lamport      | Leslie B. Lamport (born February 7, 1941) is an American computer scientist and mathematician. Lamport is best known for his seminal work in distributed systems, and as the initial developer of the document preparation system LaTeX                                  |
| Michael Stonebraker | Michael Ralph Stonebraker (born October 11, 1943[6]) is a computer scientist specializing in database systems. Through a series of academic prototypes and commercial startups, Stonebraker's research and products are central to many relational databases.            |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

select digest, detail from t_ir_single_column where match (detail) against ("database");
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| digest              | detail                                                                                                                                                                                                                                                                   |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Edgar F. Codd       | Edgar Frank Ted Codd (19 August 1923 – 18 April 2003) was an English computer scientist who, while working for IBM, invented the relational model for database management, the theoretical basis for relational databases and relational database management systems.    |
| Michael Stonebraker | Michael Ralph Stonebraker (born October 11, 1943[6]) is a computer scientist specializing in database systems. Through a series of academic prototypes and commercial startups, Stonebraker's research and products are central to many relational databases.            |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
select /*+ use_das(t_ir_single_column) */ digest, detail from t_ir_single_column where match (detail) against ("database");
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| digest              | detail                                                                                                                                                                                                                                                                   |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Edgar F. Codd       | Edgar Frank Ted Codd (19 August 1923 – 18 April 2003) was an English computer scientist who, while working for IBM, invented the relational model for database management, the theoretical basis for relational databases and relational database management systems.    |
| Michael Stonebraker | Michael Ralph Stonebraker (born October 11, 1943[6]) is a computer scientist specializing in database systems. Through a series of academic prototypes and commercial startups, Stonebraker's research and products are central to many relational databases.            |
+---------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

select digest, detail from t_ir_single_column where match (detail) against ("computer");
+---------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| digest              | detail                                                                                                                                                                                                                                                                                            |
+---------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Yann LeCun          | Yann André LeCun[1] (born 8 July 1960) is a Turing Award winning French computer scientist working primarily in the fields of machine learning, computer vision, mobile robotics and computational neuroscience.                                                                                  |
| Gerard Salton       | Gerard A. Gerry Salton (8 March 1927 – 28 August 1995) was a professor of Computer Science at Cornell University. Salton was perhaps the leading computer scientist working in the field of information retrieval during his time, and the father of Information Retrieval                        |
| Geoffrey Hinton     | Geoffrey Everest Hinton CC FRS FRSC (born 6 December 1947) is a British-Canadian computer scientist and cognitive psychologist, most noted for his work on artificial neural networks.                                                                                                            |
| Ken Thompson        | Kenneth Lane Thompson (born February 4, 1943) is an American pioneer of computer science. Thompson worked at Bell Labs for most of his career where he designed and implemented the original Unix operating system.                                                                               |
| Leslie Lamport      | Leslie B. Lamport (born February 7, 1941) is an American computer scientist and mathematician. Lamport is best known for his seminal work in distributed systems, and as the initial developer of the document preparation system LaTeX                                                           |
| Michael Stonebraker | Michael Ralph Stonebraker (born October 11, 1943[6]) is a computer scientist specializing in database systems. Through a series of academic prototypes and commercial startups, Stonebraker's research and products are central to many relational databases.                                     |
| Edgar F. Codd       | Edgar Frank Ted Codd (19 August 1923 – 18 April 2003) was an English computer scientist who, while working for IBM, invented the relational model for database management, the theoretical basis for relational databases and relational database management systems.                             |
| Gordon Plotkin      | Gordon David Plotkin, FRS FRSE MAE (born 9 September 1946) is a theoretical computer scientist in the School of Informatics at the University of Edinburgh. Plotkin is probably best known for his introduction of structural operational semantics (SOS) and his work on denotational semantics. |
+---------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
select /*+ use_das(t_ir_single_column) */ digest, detail from t_ir_single_column where match (detail) against ("computer");
+---------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| digest              | detail                                                                                                                                                                                                                                                                                            |
+---------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Yann LeCun          | Yann André LeCun[1] (born 8 July 1960) is a Turing Award winning French computer scientist working primarily in the fields of machine learning, computer vision, mobile robotics and computational neuroscience.                                                                                  |
| Gerard Salton       | Gerard A. Gerry Salton (8 March 1927 – 28 August 1995) was a professor of Computer Science at Cornell University. Salton was perhaps the leading computer scientist working in the field of information retrieval during his time, and the father of Information Retrieval                        |
| Geoffrey Hinton     | Geoffrey Everest Hinton CC FRS FRSC (born 6 December 1947) is a British-Canadian computer scientist and cognitive psychologist, most noted for his work on artificial neural networks.                                                                                                            |
| Ken Thompson        | Kenneth Lane Thompson (born February 4, 1943) is an American pioneer of computer science. Thompson worked at Bell Labs for most of his career where he designed and implemented the original Unix operating system.                                                                               |
| Leslie Lamport      | Leslie B. Lamport (born February 7, 1941) is an American computer scientist and mathematician. Lamport is best known for his seminal work in distributed systems, and as the initial developer of the document preparation system LaTeX                                                           |
| Michael Stonebraker | Michael Ralph Stonebraker (born October 11, 1943[6]) is a computer scientist specializing in database systems. Through a series of academic prototypes and commercial startups, Stonebraker's research and products are central to many relational databases.                                     |
| Edgar F. Codd       | Edgar Frank Ted Codd (19 August 1923 – 18 April 2003) was an English computer scientist who, while working for IBM, invented the relational model for database management, the theoretical basis for relational databases and relational database management systems.                             |
| Gordon Plotkin      | Gordon David Plotkin, FRS FRSE MAE (born 9 September 1946) is a theoretical computer scientist in the School of Informatics at the University of Edinburgh. Plotkin is probably best known for his introduction of structural operational semantics (SOS) and his work on denotational semantics. |
+---------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

select digest, match (detail) against ("computer") as relevance from t_ir_single_column where match (detail) against ("computer") > 0.12 order by relevance desc;
+---------------------+---------------------+
| digest              | relevance           |
+---------------------+---------------------+
| Yann LeCun          |  0.2466367713004485 |
| Gerard Salton       |  0.2282157676348548 |
| Geoffrey Hinton     |  0.1676829268292683 |
| Ken Thompson        | 0.15895953757225437 |
| Leslie Lamport      | 0.15492957746478875 |
| Michael Stonebraker |  0.1510989010989011 |
| Edgar F. Codd       | 0.14397905759162308 |
| Gordon Plotkin      | 0.13447432762836187 |
+---------------------+---------------------+
select digest, match (detail) against ("computer") as relevance from t_ir_single_column where match (detail) against ("computer") < 0.12 order by relevance desc;
+--------+-----------+
| digest | relevance |
+--------+-----------+
+--------+-----------+
select digest, match (detail) against ("computer") as relevance from t_ir_single_column where match (detail) against ("computer") = 0 order by relevance desc;
+--------+-----------+
| digest | relevance |
+--------+-----------+
+--------+-----------+

explain
select
    digest, match (detail) against ("database") as relevance
from
    t_ir_single_column
where
    match (detail) against ("database")
order by relevance desc;
Query Plan
=============================================================================
|ID|OPERATOR                   |NAME                  |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |                      |2       |42          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000              |2       |39          |
|2 |  └─SORT                   |                      |2       |32          |
|3 |    └─PX PARTITION ITERATOR|                      |2       |32          |
|4 |      └─TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|2       |32          |
=============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_ir_single_column.digest, MATCH(t_ir_single_column.detail) AGAINST('database'))]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('database'), DESC])
  1 - output([MATCH(t_ir_single_column.detail) AGAINST('database')], [INTERNAL_FUNCTION(t_ir_single_column.digest, MATCH(t_ir_single_column.detail) AGAINST('database'))]), filter(nil), rowset=16
      dop=1
  2 - output([MATCH(t_ir_single_column.detail) AGAINST('database')], [t_ir_single_column.digest]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('database'), DESC])
  3 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('database')]), filter(nil), rowset=16
      force partition granule
  4 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('database')]), filter(nil), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('database')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('database'))

select
    digest, match (detail) against ("database") as relevance
from
    t_ir_single_column
where
    match (detail) against ("database")
order by relevance desc;
+---------------------+--------------------+
| digest              | relevance          |
+---------------------+--------------------+
| Edgar F. Codd       | 0.7734669264945429 |
| Michael Stonebraker | 0.5121031024318263 |
+---------------------+--------------------+


select
    digest, match (detail) against ("computer") as relevance
from
    t_ir_single_column
where
    match (detail) against ("computer")
order by relevance desc;
+---------------------+---------------------+
| digest              | relevance           |
+---------------------+---------------------+
| Yann LeCun          |  0.2466367713004485 |
| Gerard Salton       |  0.2282157676348548 |
| Geoffrey Hinton     |  0.1676829268292683 |
| Ken Thompson        | 0.15895953757225437 |
| Leslie Lamport      | 0.15492957746478875 |
| Michael Stonebraker |  0.1510989010989011 |
| Edgar F. Codd       | 0.14397905759162308 |
| Gordon Plotkin      | 0.13447432762836187 |
+---------------------+---------------------+

explain
select /*+ use_das(t_ir_single_column) */
    digest, match (detail) against ("computer") as relevance
from
    t_ir_single_column
where
    match (detail) against ("computer")
order by relevance desc;
Query Plan
===================================================================================
|ID|OPERATOR                         |NAME                  |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |SORT                             |                      |8       |65          |
|1 |└─DISTRIBUTED TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|8       |62          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('computer'), DESC])
  1 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('computer')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('computer'))

select /*+ use_das(t_ir_single_column) */
    digest, match (detail) against ("computer") as relevance
from
    t_ir_single_column
where
    match (detail) against ("computer")
order by relevance desc;
+---------------------+---------------------+
| digest              | relevance           |
+---------------------+---------------------+
| Yann LeCun          |  0.2466367713004485 |
| Gerard Salton       |  0.2282157676348548 |
| Geoffrey Hinton     |  0.1676829268292683 |
| Ken Thompson        | 0.15895953757225437 |
| Leslie Lamport      | 0.15492957746478875 |
| Michael Stonebraker |  0.1510989010989011 |
| Edgar F. Codd       | 0.14397905759162308 |
| Gordon Plotkin      | 0.13447432762836187 |
+---------------------+---------------------+

explain
select
    digest, match (detail) against ("computer") as relevance
from
    t_ir_single_column
where
    match (detail) against ("computer")
order by relevance desc
limit 4;
Query Plan
===============================================================================
|ID|OPERATOR                     |NAME                  |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------
|0 |LIMIT                        |                      |4       |82          |
|1 |└─PX COORDINATOR MERGE SORT  |                      |4       |82          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000              |4       |76          |
|3 |    └─TOP-N SORT             |                      |4       |63          |
|4 |      └─PX PARTITION ITERATOR|                      |8       |62          |
|5 |        └─TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|8       |62          |
===============================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      limit(4), offset(nil)
  1 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('computer'), DESC])
  2 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      dop=1
  3 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('computer'), DESC]), topn(4)
  4 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      force partition granule
  5 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('computer')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('computer')),
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('computer'), DESC]), limit(4), offset(nil), with_ties(false)

select
    digest, match (detail) against ("computer") as relevance
from
    t_ir_single_column
where
    match (detail) against ("computer")
order by relevance desc
limit 4;
+-----------------+---------------------+
| digest          | relevance           |
+-----------------+---------------------+
| Yann LeCun      |  0.2466367713004485 |
| Gerard Salton   |  0.2282157676348548 |
| Geoffrey Hinton |  0.1676829268292683 |
| Ken Thompson    | 0.15895953757225437 |
+-----------------+---------------------+

explain
select /*+ use_das(t_ir_single_column) */
    digest, match (detail) against ("computer") as relevance
from
    t_ir_single_column
where
    match (detail) against ("computer")
order by relevance desc
limit 4;
Query Plan
===================================================================================
|ID|OPERATOR                         |NAME                  |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |TOP-N SORT                       |                      |4       |63          |
|1 |└─DISTRIBUTED TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|8       |62          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('computer'), DESC]), topn(4)
  1 - output([t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('computer')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('computer')),
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('computer'), DESC]), limit(4), offset(nil), with_ties(false)

select /*+ use_das(t_ir_single_column) */
    digest, match (detail) against ("computer") as relevance
from
    t_ir_single_column
where
    match (detail) against ("computer")
order by relevance desc
limit 4;
+-----------------+---------------------+
| digest          | relevance           |
+-----------------+---------------------+
| Yann LeCun      |  0.2466367713004485 |
| Gerard Salton   |  0.2282157676348548 |
| Geoffrey Hinton |  0.1676829268292683 |
| Ken Thompson    | 0.15895953757225437 |
+-----------------+---------------------+

explain
select
    digest, seq, match (detail) against ("scientist") as relevance
from
    t_ir_single_column
where
    match (detail) against ("scientist") and seq < 4
order by relevance desc, seq desc;
Query Plan
=============================================================================
|ID|OPERATOR                   |NAME                  |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |                      |1       |59          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000              |1       |58          |
|2 |  └─SORT                   |                      |1       |55          |
|3 |    └─PX PARTITION ITERATOR|                      |1       |55          |
|4 |      └─TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|1       |55          |
=============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_ir_single_column.digest, t_ir_single_column.seq, MATCH(t_ir_single_column.detail) AGAINST('scientist'))]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('scientist'), DESC], [t_ir_single_column.seq, DESC])
  1 - output([MATCH(t_ir_single_column.detail) AGAINST('scientist')], [t_ir_single_column.seq], [INTERNAL_FUNCTION(t_ir_single_column.digest, t_ir_single_column.seq,
       MATCH(t_ir_single_column.detail) AGAINST('scientist'))]), filter(nil), rowset=16
      dop=1
  2 - output([MATCH(t_ir_single_column.detail) AGAINST('scientist')], [t_ir_single_column.seq], [t_ir_single_column.digest]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('scientist'), DESC], [t_ir_single_column.seq, DESC])
  3 - output([t_ir_single_column.seq], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('scientist')]), filter(nil), rowset=16
      force partition granule
  4 - output([t_ir_single_column.seq], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('scientist')]), filter([t_ir_single_column.seq
      < 4]), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('scientist')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('scientist'))

select
    digest, seq, match (detail) against ("scientist") as relevance
from
    t_ir_single_column
where
    match (detail) against ("scientist") and seq < 4
order by relevance desc, seq desc;
+---------------------+-----+---------------------+
| digest              | seq | relevance           |
+---------------------+-----+---------------------+
| Geoffrey Hinton     |   3 |  0.1676829268292683 |
| Michael Stonebraker |   2 |  0.1510989010989011 |
| Edgar F. Codd       |   1 | 0.14397905759162308 |
| Gerard Salton       |   0 | 0.14397905759162308 |
+---------------------+-----+---------------------+

select
    digest, seq, match (detail) against ("scientist") as relevance
from
    t_ir_single_column
where
    match (detail) against ("scientist") and seq >= 4;
+----------------+-----+---------------------+
| digest         | seq | relevance           |
+----------------+-----+---------------------+
| Yann LeCun     |   4 | 0.15895953757225437 |
| Leslie Lamport |   7 | 0.15492957746478875 |
| Gordon Plotkin |   6 | 0.13447432762836187 |
+----------------+-----+---------------------+

select
    digest, seq, match (detail) against ("scientist") as relevance
from
    t_ir_single_column
where
    match (detail) against ("scientist") and digest = "Ken Thompson";
+--------+-----+-----------+
| digest | seq | relevance |
+--------+-----+-----------+
+--------+-----+-----------+

select
    digest, seq, match (detail) against ("scientist") as relevance
from
    t_ir_single_column
where
    match (detail) against ("scientist") and digest = "Yann LeCun";
+------------+-----+---------------------+
| digest     | seq | relevance           |
+------------+-----+---------------------+
| Yann LeCun |   4 | 0.15895953757225437 |
+------------+-----+---------------------+

explain
select
    digest, seq, match (detail) against ("scientist") as relevance
from
    t_ir_single_column
where
    match (detail) against ("scientist") and digest like "%Ken%";
Query Plan
=============================================================================
|ID|OPERATOR                   |NAME                  |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |                      |7       |95          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000              |7       |84          |
|2 |  └─SORT                   |                      |7       |61          |
|3 |    └─PX PARTITION ITERATOR|                      |7       |58          |
|4 |      └─TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|7       |58          |
=============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_ir_single_column.digest, t_ir_single_column.seq, MATCH(t_ir_single_column.detail) AGAINST('scientist'))]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('scientist'), DESC])
  1 - output([MATCH(t_ir_single_column.detail) AGAINST('scientist')], [INTERNAL_FUNCTION(t_ir_single_column.digest, t_ir_single_column.seq, MATCH(t_ir_single_column.detail)
      AGAINST('scientist'))]), filter(nil), rowset=16
      dop=1
  2 - output([MATCH(t_ir_single_column.detail) AGAINST('scientist')], [t_ir_single_column.seq], [t_ir_single_column.digest]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('scientist'), DESC])
  3 - output([t_ir_single_column.seq], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('scientist')]), filter(nil), rowset=16
      force partition granule
  4 - output([t_ir_single_column.seq], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('scientist')]), filter([(T_OP_LIKE, t_ir_single_column.digest,
       '%Ken%', '\\')]), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('scientist')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('scientist'))

select
    digest, seq, match (detail) against ("scientist") as relevance
from
    t_ir_single_column
where
    match (detail) against ("scientist") and digest like "%Ken%";
+--------+-----+-----------+
| digest | seq | relevance |
+--------+-----+-----------+
+--------+-----+-----------+

select
    digest, seq, match (detail) against ("scientist") as relevance
from
    t_ir_single_column
where
    match (detail) against ("scientist") and digest like "%LeCun%";
+------------+-----+---------------------+
| digest     | seq | relevance           |
+------------+-----+---------------------+
| Yann LeCun |   4 | 0.15895953757225437 |
+------------+-----+---------------------+

select
    digest, match (detail) against ("distributed database") as relevance
from
    t_ir_single_column
where
    match (detail) against ("distributed database")
order by
    relevance desc;
+---------------------+--------------------+
| digest              | relevance          |
+---------------------+--------------------+
| Edgar F. Codd       | 0.7734669264945429 |
| Leslie Lamport      | 0.5250859979864361 |
| Michael Stonebraker | 0.5121031024318263 |
+---------------------+--------------------+

select
    digest, match (detail) against ("relational database") as relevance
from
    t_ir_single_column
where
    match (detail) against ("relational database")
order by
    relevance desc;
+---------------------+--------------------+
| digest              | relevance          |
+---------------------+--------------------+
| Edgar F. Codd       |  1.734320170232609 |
| Michael Stonebraker | 1.0242062048636527 |
+---------------------+--------------------+

select
    digest, match (detail) against ("relational distributed database") as relevance
from
    t_ir_single_column
where
    match (detail) against ("relational distributed database")
order by
    relevance desc;
+---------------------+--------------------+
| digest              | relevance          |
+---------------------+--------------------+
| Edgar F. Codd       |  1.734320170232609 |
| Michael Stonebraker | 1.0242062048636527 |
| Leslie Lamport      | 0.5250859979864361 |
+---------------------+--------------------+

select
    digest, match (detail) against ("distributed relational database") as relevance
from
    t_ir_single_column
where
    match (detail) against ("distributed relational database")
order by
    relevance desc;
+---------------------+--------------------+
| digest              | relevance          |
+---------------------+--------------------+
| Edgar F. Codd       |  1.734320170232609 |
| Michael Stonebraker | 1.0242062048636527 |
| Leslie Lamport      | 0.5250859979864361 |
+---------------------+--------------------+

select
    digest, match (detail) against ("distributed relational database") as relevance
from
    t_ir_single_column
where
    match (detail) against ("distributed relational database")
limit 2;
+---------------------+--------------------+
| digest              | relevance          |
+---------------------+--------------------+
| Edgar F. Codd       |  1.734320170232609 |
| Michael Stonebraker | 1.0242062048636527 |
+---------------------+--------------------+

select /*+ use_das(t_ir_single_column) */
    digest, match (detail) against ("distributed relational database") as relevance
from
    t_ir_single_column
where
    match (detail) against ("distributed relational database")
limit 2;
+---------------------+--------------------+
| digest              | relevance          |
+---------------------+--------------------+
| Edgar F. Codd       |  1.734320170232609 |
| Michael Stonebraker | 1.0242062048636527 |
+---------------------+--------------------+

explain
select
    t_ir_single_column.digest, t_dim_table.seq as seq, t_dim_table.log as log , match (detail) against ("computer") as score
from
    t_ir_single_column, t_dim_table
where
    t_ir_single_column.seq = t_dim_table.seq and match (detail) against ("computer")
order by
    score desc;
Query Plan
=====================================================================================
|ID|OPERATOR                           |NAME                  |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |                      |5       |121         |
|1 |└─EXCHANGE OUT DISTR               |:EX10001              |5       |109         |
|2 |  └─SORT                           |                      |5       |83          |
|3 |    └─HASH JOIN                    |                      |5       |81          |
|4 |      ├─EXCHANGE IN DISTR          |                      |5       |17          |
|5 |      │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000              |5       |13          |
|6 |      │   └─TABLE FULL SCAN        |t_dim_table           |5       |3           |
|7 |      └─PX PARTITION ITERATOR      |                      |8       |62          |
|8 |        └─TEXT RETRIEVAL SCAN      |t_ir_single_column(i1)|8       |62          |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_ir_single_column.digest, t_dim_table.seq, t_dim_table.log, MATCH(t_ir_single_column.detail) AGAINST('computer'))]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('computer'), DESC])
  1 - output([MATCH(t_ir_single_column.detail) AGAINST('computer')], [INTERNAL_FUNCTION(t_ir_single_column.digest, t_dim_table.seq, t_dim_table.log, MATCH(t_ir_single_column.detail)
      AGAINST('computer'))]), filter(nil), rowset=16
      dop=1
  2 - output([MATCH(t_ir_single_column.detail) AGAINST('computer')], [t_dim_table.seq], [t_dim_table.log], [t_ir_single_column.digest]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('computer'), DESC])
  3 - output([MATCH(t_ir_single_column.detail) AGAINST('computer')], [t_dim_table.seq], [t_dim_table.log], [t_ir_single_column.digest]), filter(nil), rowset=16
      equal_conds([t_ir_single_column.seq = t_dim_table.seq]), other_conds(nil)
  4 - output([t_dim_table.seq], [t_dim_table.log]), filter(nil), rowset=16
  5 - output([t_dim_table.seq], [t_dim_table.log]), filter(nil), rowset=16
      (#keys=1, [t_dim_table.seq]), is_single, dop=1
  6 - output([t_dim_table.seq], [t_dim_table.log]), filter(nil), rowset=16
      access([t_dim_table.seq], [t_dim_table.log]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t_dim_table.__pk_increment]), range(MIN ; MAX)always true
  7 - output([t_ir_single_column.seq], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t_ir_single_column.seq], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('computer')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('computer'))

select
    t_ir_single_column.digest, t_dim_table.seq as seq, t_dim_table.log as log , match (detail) against ("computer") as score
from
    t_ir_single_column, t_dim_table
where
    t_ir_single_column.seq = t_dim_table.seq and match (detail) against ("computer")
order by
    score desc;
+-----------------+------+-------------+---------------------+
| digest          | seq  | log         | score               |
+-----------------+------+-------------+---------------------+
| Geoffrey Hinton |    3 | Hinton log  |  0.1676829268292683 |
| Ken Thompson    |    5 | Ken log     | 0.15895953757225437 |
| Leslie Lamport  |    7 | Lamport log | 0.15492957746478875 |
| Edgar F. Codd   |    1 | Codd log    | 0.14397905759162308 |
+-----------------+------+-------------+---------------------+

explain
select /*+ use_das(t_ir_single_column) */
    t_ir_single_column.digest, t_dim_table.seq as seq, t_dim_table.log as log , match (detail) against ("computer") as score
from
    t_ir_single_column, t_dim_table
where
    t_ir_single_column.seq = t_dim_table.seq and match (detail) against ("computer")
order by
    score desc;
Query Plan
=====================================================================================
|ID|OPERATOR                           |NAME                  |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |SORT                               |                      |5       |69          |
|1 |└─HASH JOIN                        |                      |5       |67          |
|2 |  ├─TABLE FULL SCAN                |t_dim_table           |5       |3           |
|3 |  └─DISTRIBUTED TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|8       |62          |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_ir_single_column.digest], [t_dim_table.seq], [t_dim_table.log], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('computer'), DESC])
  1 - output([MATCH(t_ir_single_column.detail) AGAINST('computer')], [t_ir_single_column.digest], [t_dim_table.seq], [t_dim_table.log]), filter(nil), rowset=16
      equal_conds([t_ir_single_column.seq = t_dim_table.seq]), other_conds(nil)
  2 - output([t_dim_table.seq], [t_dim_table.log]), filter(nil), rowset=16
      access([t_dim_table.seq], [t_dim_table.log]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t_dim_table.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t_ir_single_column.seq], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('computer')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('computer'))

select /*+ use_das(t_ir_single_column) */
    t_ir_single_column.digest, t_dim_table.seq as seq, t_dim_table.log as log , match (detail) against ("computer") as score
from
    t_ir_single_column, t_dim_table
where
    t_ir_single_column.seq = t_dim_table.seq and match (detail) against ("computer")
order by
    score desc;
+-----------------+------+-------------+---------------------+
| digest          | seq  | log         | score               |
+-----------------+------+-------------+---------------------+
| Geoffrey Hinton |    3 | Hinton log  |  0.1676829268292683 |
| Ken Thompson    |    5 | Ken log     | 0.15895953757225437 |
| Leslie Lamport  |    7 | Lamport log | 0.15492957746478875 |
| Edgar F. Codd   |    1 | Codd log    | 0.14397905759162308 |
+-----------------+------+-------------+---------------------+

explain
select /*+ use_das(t_ir_single_column), use_das(t_dim_table) */
    t_ir_single_column.digest, t_dim_table.seq as seq, t_dim_table.log as log , match (detail) against ("computer") as score
from
    t_ir_single_column, t_dim_table
where
    t_ir_single_column.seq = t_dim_table.seq and match (detail) against ("computer")
order by
    score desc;
Query Plan
=====================================================================================
|ID|OPERATOR                           |NAME                  |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |SORT                               |                      |5       |69          |
|1 |└─HASH JOIN                        |                      |5       |67          |
|2 |  ├─DISTRIBUTED TABLE FULL SCAN    |t_dim_table           |5       |3           |
|3 |  └─DISTRIBUTED TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|8       |62          |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_ir_single_column.digest], [t_dim_table.seq], [t_dim_table.log], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('computer'), DESC])
  1 - output([MATCH(t_ir_single_column.detail) AGAINST('computer')], [t_ir_single_column.digest], [t_dim_table.seq], [t_dim_table.log]), filter(nil), rowset=16
      equal_conds([t_ir_single_column.seq = t_dim_table.seq]), other_conds(nil)
  2 - output([t_dim_table.seq], [t_dim_table.log]), filter(nil), rowset=16
      access([t_dim_table.seq], [t_dim_table.log]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t_dim_table.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t_ir_single_column.seq], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('computer')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('computer'))

select /*+ use_das(t_ir_single_column), use_das(t_dim_table) */
    t_ir_single_column.digest, t_dim_table.seq as seq, t_dim_table.log as log , match (detail) against ("computer") as score
from
    t_ir_single_column, t_dim_table
where
    t_ir_single_column.seq = t_dim_table.seq and match (detail) against ("computer")
order by
    score desc;
+-----------------+------+-------------+---------------------+
| digest          | seq  | log         | score               |
+-----------------+------+-------------+---------------------+
| Geoffrey Hinton |    3 | Hinton log  |  0.1676829268292683 |
| Ken Thompson    |    5 | Ken log     | 0.15895953757225437 |
| Leslie Lamport  |    7 | Lamport log | 0.15492957746478875 |
| Edgar F. Codd   |    1 | Codd log    | 0.14397905759162308 |
+-----------------+------+-------------+---------------------+

explain
select /*+ use_das(t_ir_single_column) */
    t_ir_single_column.digest, t_ir_single_column.seq, t_dim_table.seq, t_dim_table.log as log , match (detail) against ("computer") as score
from
    t_ir_single_column, t_dim_table
where
    t_ir_single_column.seq < t_dim_table.seq and match (detail) against ("computer")
order by
    t_ir_single_column.seq, t_dim_table.seq;
Query Plan
==============================================================================
|ID|OPERATOR                        |NAME              |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |SORT                            |                  |5       |1365        |
|1 |└─NESTED-LOOP JOIN              |                  |5       |1362        |
|2 |  ├─TABLE FULL SCAN             |t_dim_table       |5       |3           |
|3 |  └─DISTRIBUTED TABLE RANGE SCAN|t_ir_single_column|3       |272         |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_ir_single_column.digest], [t_ir_single_column.seq], [t_dim_table.seq], [t_dim_table.log], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      sort_keys([t_ir_single_column.seq, ASC], [t_dim_table.seq, ASC])
  1 - output([t_ir_single_column.seq], [t_dim_table.seq], [t_ir_single_column.digest], [t_dim_table.log], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter(nil), rowset=16
      conds(nil), nl_params_([t_dim_table.seq(:0)]), use_batch=false
  2 - output([t_dim_table.seq], [t_dim_table.log]), filter(nil), rowset=16
      access([t_dim_table.seq], [t_dim_table.log]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t_dim_table.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t_ir_single_column.seq], [t_ir_single_column.digest], [MATCH(t_ir_single_column.detail) AGAINST('computer')]), filter([MATCH(t_ir_single_column.detail)
      AGAINST('computer')]), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([t_ir_single_column.seq]), range(MIN ; MAX),
      range_cond([t_ir_single_column.seq < :0]), has_functional_lookup=true

select /*+ use_das(t_ir_single_column) */
    t_ir_single_column.digest, t_ir_single_column.seq, t_dim_table.seq, t_dim_table.log as log , match (detail) against ("computer") as score
from
    t_ir_single_column, t_dim_table
where
    t_ir_single_column.seq < t_dim_table.seq and match (detail) against ("computer")
order by
    t_ir_single_column.seq, t_dim_table.seq;
+---------------------+-----+------+---------------+---------------------+
| digest              | seq | seq  | log           | score               |
+---------------------+-----+------+---------------+---------------------+
| Gerard Salton       |   0 |    1 | Codd log      |  0.2282157676348548 |
| Gerard Salton       |   0 |    3 | Hinton log    |  0.2282157676348548 |
| Gerard Salton       |   0 |    5 | Ken log       |  0.2282157676348548 |
| Gerard Salton       |   0 |    7 | Lamport log   |  0.2282157676348548 |
| Gerard Salton       |   0 |    9 | someone's log |  0.2282157676348548 |
| Edgar F. Codd       |   1 |    3 | Hinton log    | 0.14397905759162308 |
| Edgar F. Codd       |   1 |    5 | Ken log       | 0.14397905759162308 |
| Edgar F. Codd       |   1 |    7 | Lamport log   | 0.14397905759162308 |
| Edgar F. Codd       |   1 |    9 | someone's log | 0.14397905759162308 |
| Michael Stonebraker |   2 |    3 | Hinton log    |  0.1510989010989011 |
| Michael Stonebraker |   2 |    5 | Ken log       |  0.1510989010989011 |
| Michael Stonebraker |   2 |    7 | Lamport log   |  0.1510989010989011 |
| Michael Stonebraker |   2 |    9 | someone's log |  0.1510989010989011 |
| Geoffrey Hinton     |   3 |    5 | Ken log       |  0.1676829268292683 |
| Geoffrey Hinton     |   3 |    7 | Lamport log   |  0.1676829268292683 |
| Geoffrey Hinton     |   3 |    9 | someone's log |  0.1676829268292683 |
| Yann LeCun          |   4 |    5 | Ken log       |  0.2466367713004485 |
| Yann LeCun          |   4 |    7 | Lamport log   |  0.2466367713004485 |
| Yann LeCun          |   4 |    9 | someone's log |  0.2466367713004485 |
| Ken Thompson        |   5 |    7 | Lamport log   | 0.15895953757225437 |
| Ken Thompson        |   5 |    9 | someone's log | 0.15895953757225437 |
| Gordon Plotkin      |   6 |    7 | Lamport log   | 0.13447432762836187 |
| Gordon Plotkin      |   6 |    9 | someone's log | 0.13447432762836187 |
| Leslie Lamport      |   7 |    9 | someone's log | 0.15492957746478875 |
+---------------------+-----+------+---------------+---------------------+

explain select distinct 1 from t_ir_single_column where match (detail) against ("distributed database");
Query Plan
===============================================================================
|ID|OPERATOR                     |NAME                  |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------
|0 |LIMIT                        |                      |1       |39          |
|1 |└─PX COORDINATOR             |                      |1       |39          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000              |1       |38          |
|3 |    └─LIMIT                  |                      |1       |37          |
|4 |      └─PX PARTITION ITERATOR|                      |1       |37          |
|5 |        └─TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|1       |37          |
===============================================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      limit(1), offset(nil)
  1 - output(nil), filter(nil), rowset=16
  2 - output(nil), filter(nil), rowset=16
      dop=1
  3 - output(nil), filter(nil), rowset=16
      limit(1), offset(nil)
  4 - output(nil), filter(nil), rowset=16
      force partition granule
  5 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p[0-1])
      limit(1), offset(nil), is_index_back=false, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('distributed database')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('distributed database'))
select distinct 1 from t_ir_single_column where match (detail) against ("distributed database");
+---+
| 1 |
+---+
| 1 |
+---+

explain select /*+ use_das(t_ir_single_column) */ distinct 1 from t_ir_single_column where match (detail) against ("distributed database");
Query Plan
===================================================================================
|ID|OPERATOR                         |NAME                  |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                            |                      |1       |37          |
|1 |└─DISTRIBUTED TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|1       |37          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      limit(1), offset(nil)
  1 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p[0-1])
      limit(1), offset(nil), is_index_back=false, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('distributed database')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('distributed database'))
select /*+ use_das(t_ir_single_column) */ distinct 1 from t_ir_single_column where match (detail) against ("distributed database");
+---+
| 1 |
+---+
| 1 |
+---+

explain select distinct digest from t_ir_single_column where match (detail) against ("distributed database");
Query Plan
===================================================================================
|ID|OPERATOR                         |NAME                  |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |PX COORDINATOR                   |                      |3       |74          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001              |3       |72          |
|2 |  └─HASH DISTINCT                |                      |3       |67          |
|3 |    └─EXCHANGE IN DISTR          |                      |3       |66          |
|4 |      └─EXCHANGE OUT DISTR (HASH)|:EX10000              |3       |64          |
|5 |        └─HASH DISTINCT          |                      |3       |59          |
|6 |          └─PX PARTITION ITERATOR|                      |3       |58          |
|7 |            └─TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|3       |58          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_ir_single_column.digest)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t_ir_single_column.digest)]), filter(nil), rowset=16
      dop=1
  2 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      distinct([t_ir_single_column.digest])
  3 - output([t_ir_single_column.digest]), filter(nil), rowset=16
  4 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      (#keys=1, [t_ir_single_column.digest]), dop=1
  5 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      distinct([t_ir_single_column.digest])
  6 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      force partition granule
  7 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('distributed database')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('distributed database'))
select distinct digest from t_ir_single_column where match (detail) against ("distributed database");
+---------------------+
| digest              |
+---------------------+
| Michael Stonebraker |
| Edgar F. Codd       |
| Leslie Lamport      |
+---------------------+

explain select /*+ use_das(t_ir_single_column) */ distinct digest from t_ir_single_column where match (detail) against ("distributed database");
Query Plan
===================================================================================
|ID|OPERATOR                         |NAME                  |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |HASH DISTINCT                    |                      |3       |59          |
|1 |└─DISTRIBUTED TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|3       |58          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      distinct([t_ir_single_column.digest])
  1 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      access([t_ir_single_column.seq], [t_ir_single_column.digest]), partitions(p[0-1])
      is_index_back=true, is_global_index=false,
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('distributed database')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('distributed database'))
select /*+ use_das(t_ir_single_column) */ distinct digest from t_ir_single_column where match (detail) against ("distributed database");
+---------------------+
| digest              |
+---------------------+
| Michael Stonebraker |
| Edgar F. Codd       |
| Leslie Lamport      |
+---------------------+

explain select (select digest from t_ir_single_column limit 1) as d1 from t_ir_single_column where match (detail) against ("distributed database") and seq > 1 ;
Query Plan
===================================================================================
|ID|OPERATOR                         |NAME                  |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |SORT                             |                      |1       |65          |
|1 |└─SUBPLAN FILTER                 |                      |1       |65          |
|2 |  ├─PX COORDINATOR               |                      |1       |58          |
|3 |  │ └─EXCHANGE OUT DISTR         |:EX10000              |1       |58          |
|4 |  │   └─PX PARTITION ITERATOR    |                      |1       |57          |
|5 |  │     └─TEXT RETRIEVAL SCAN    |t_ir_single_column(i1)|1       |57          |
|6 |  └─LIMIT                        |                      |1       |7           |
|7 |    └─PX COORDINATOR             |                      |1       |7           |
|8 |      └─EXCHANGE OUT DISTR       |:EX20000              |1       |6           |
|9 |        └─LIMIT                  |                      |1       |5           |
|10|          └─PX PARTITION ITERATOR|                      |1       |5           |
|11|            └─TABLE FULL SCAN    |t_ir_single_column    |1       |5           |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([:0]), filter(nil), rowset=16
      sort_keys([MATCH(t_ir_single_column.detail) AGAINST('distributed database'), DESC])
  1 - output([MATCH(t_ir_single_column.detail) AGAINST('distributed database')], [:0]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([subquery(1)(:0)]), init_plan_idxs_(nil), use_batch=false
  2 - output([MATCH(t_ir_single_column.detail) AGAINST('distributed database')]), filter(nil), rowset=16
  3 - output([MATCH(t_ir_single_column.detail) AGAINST('distributed database')]), filter(nil), rowset=16
      dop=1
  4 - output([MATCH(t_ir_single_column.detail) AGAINST('distributed database')]), filter(nil), rowset=16
      force partition granule
  5 - output([MATCH(t_ir_single_column.detail) AGAINST('distributed database')]), filter([t_ir_single_column.seq > 1]), rowset=16
      access([t_ir_single_column.seq]), partitions(p[0-1])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('distributed database')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('distributed database'))
  6 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      limit(1), offset(nil)
  7 - output([t_ir_single_column.digest]), filter(nil), rowset=16
  8 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      dop=1
  9 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      limit(1), offset(nil)
 10 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      force partition granule
 11 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      access([t_ir_single_column.digest]), partitions(p[0-1])
      limit(1), offset(nil), is_index_back=false, is_global_index=false,
      range_key([t_ir_single_column.seq]), range(MIN ; MAX)always true
select (select digest from t_ir_single_column limit 1) as d1 from t_ir_single_column where match (detail) against ("distributed database") and seq > 1 ;
+---------------+
| d1            |
+---------------+
| Gerard Salton |
| Gerard Salton |
+---------------+

explain select distinct (select digest from t_ir_single_column limit 1) as d1 from t_ir_single_column where match (detail) against ("distributed database") and seq > 1;
Query Plan
=================================================================================
|ID|OPERATOR                       |NAME                  |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------
|0 |SUBPLAN FILTER                 |                      |1       |65          |
|1 |├─LIMIT                        |                      |1       |58          |
|2 |│ └─PX COORDINATOR             |                      |1       |58          |
|3 |│   └─EXCHANGE OUT DISTR       |:EX10000              |1       |58          |
|4 |│     └─LIMIT                  |                      |1       |57          |
|5 |│       └─PX PARTITION ITERATOR|                      |1       |57          |
|6 |│         └─TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|1       |57          |
|7 |└─LIMIT                        |                      |1       |7           |
|8 |  └─PX COORDINATOR             |                      |1       |7           |
|9 |    └─EXCHANGE OUT DISTR       |:EX20000              |1       |6           |
|10|      └─LIMIT                  |                      |1       |5           |
|11|        └─PX PARTITION ITERATOR|                      |1       |5           |
|12|          └─TABLE FULL SCAN    |t_ir_single_column    |1       |5           |
=================================================================================
Outputs & filters:
-------------------------------------
  0 - output([:0]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([subquery(1)(:0)]), init_plan_idxs_(nil), use_batch=false
  1 - output(nil), filter(nil), rowset=16
      limit(1), offset(nil)
  2 - output(nil), filter(nil), rowset=16
  3 - output(nil), filter(nil), rowset=16
      dop=1
  4 - output(nil), filter(nil), rowset=16
      limit(1), offset(nil)
  5 - output(nil), filter(nil), rowset=16
      force partition granule
  6 - output(nil), filter([t_ir_single_column.seq > 1]), rowset=16
      access([t_ir_single_column.seq]), partitions(p[0-1])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('distributed database')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('distributed database'))
  7 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      limit(1), offset(nil)
  8 - output([t_ir_single_column.digest]), filter(nil), rowset=16
  9 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      dop=1
 10 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      limit(1), offset(nil)
 11 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      force partition granule
 12 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      access([t_ir_single_column.digest]), partitions(p[0-1])
      limit(1), offset(nil), is_index_back=false, is_global_index=false,
      range_key([t_ir_single_column.seq]), range(MIN ; MAX)always true
select distinct (select digest from t_ir_single_column limit 1) as d1 from t_ir_single_column where match (detail) against ("distributed database") and seq > 1;
+---------------+
| d1            |
+---------------+
| Gerard Salton |
+---------------+

explain select /*+ use_das(t_ir_single_column) */ distinct (select digest from t_ir_single_column limit 1) as d1 from t_ir_single_column where match (detail) against ("distributed database") and seq > 1;
Query Plan
=====================================================================================
|ID|OPERATOR                           |NAME                  |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------------
|0 |SUBPLAN FILTER                     |                      |1       |63          |
|1 |├─LIMIT                            |                      |1       |57          |
|2 |│ └─DISTRIBUTED TEXT RETRIEVAL SCAN|t_ir_single_column(i1)|1       |57          |
|3 |└─LIMIT                            |                      |1       |7           |
|4 |  └─PX COORDINATOR                 |                      |1       |7           |
|5 |    └─EXCHANGE OUT DISTR           |:EX10000              |1       |6           |
|6 |      └─LIMIT                      |                      |1       |5           |
|7 |        └─PX PARTITION ITERATOR    |                      |1       |5           |
|8 |          └─TABLE FULL SCAN        |t_ir_single_column    |1       |5           |
=====================================================================================
Outputs & filters:
-------------------------------------
  0 - output([:0]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([subquery(1)(:0)]), init_plan_idxs_(nil), use_batch=false
  1 - output(nil), filter(nil), rowset=16
      limit(1), offset(nil)
  2 - output(nil), filter([t_ir_single_column.seq > 1]), rowset=16
      access([t_ir_single_column.seq]), partitions(p[0-1])
      is_index_back=true, is_global_index=false, filter_before_indexback[false],
      calc_relevance=true, match_expr(MATCH(t_ir_single_column.detail) AGAINST('distributed database')),
      pushdown_match_filter(MATCH(t_ir_single_column.detail) AGAINST('distributed database'))
  3 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      limit(1), offset(nil)
  4 - output([t_ir_single_column.digest]), filter(nil), rowset=16
  5 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      dop=1
  6 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      limit(1), offset(nil)
  7 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      force partition granule
  8 - output([t_ir_single_column.digest]), filter(nil), rowset=16
      access([t_ir_single_column.digest]), partitions(p[0-1])
      limit(1), offset(nil), is_index_back=false, is_global_index=false,
      range_key([t_ir_single_column.seq]), range(MIN ; MAX)always true
select /*+ use_das(t_ir_single_column) */ distinct (select digest from t_ir_single_column limit 1) as d1 from t_ir_single_column where match (detail) against ("distributed database") and seq > 1;
+---------------+
| d1            |
+---------------+
| Gerard Salton |
+---------------+

drop table if exists t_ir_single_column;
drop table if exists t_dim_table;
drop table if exists t_many_partitions;
create table t_many_partitions(
  seq int primary key,
  digest varchar(512),
  detail varchar(4096),
  fulltext index i1(detail)) partition by hash(seq) partitions 20;

insert into t_many_partitions (seq, digest, detail) values
    (1, 'digest', 'detail one'),
    (2, 'digest', 'detail two'),
    (3, 'digest', 'detail three'),
    (4, 'digest', 'detail four');
insert into t_many_partitions select seq + 8, digest, concat(detail, ' ', detail) from t_many_partitions;
insert into t_many_partitions select seq + 16, digest, concat(detail, ' ', detail, ' ', detail) from t_many_partitions;

select * from t_many_partitions where match(detail) against ('three') limit 3;
+-----+--------+-------------------------------------------------------------------------------+
| seq | digest | detail                                                                        |
+-----+--------+-------------------------------------------------------------------------------+
|  27 | digest | detail three detail three detail three detail three detail three detail three |
|  19 | digest | detail three detail three detail three                                        |
|  11 | digest | detail three detail three                                                     |
+-----+--------+-------------------------------------------------------------------------------+
select /*+ use_das(t_many_partitions) */ * from t_many_partitions where match(detail) against ('three') limit 3;
+-----+--------+-------------------------------------------------------------------------------+
| seq | digest | detail                                                                        |
+-----+--------+-------------------------------------------------------------------------------+
|  27 | digest | detail three detail three detail three detail three detail three detail three |
|  19 | digest | detail three detail three detail three                                        |
|  11 | digest | detail three detail three                                                     |
+-----+--------+-------------------------------------------------------------------------------+

select * from t_many_partitions where match(detail) against ('') limit 3;
+-----+--------+--------+
| seq | digest | detail |
+-----+--------+--------+
+-----+--------+--------+
select /*+ use_das(t_many_partitions) */ * from t_many_partitions where match(detail) against ('') limit 3;
+-----+--------+--------+
| seq | digest | detail |
+-----+--------+--------+
+-----+--------+--------+

drop table if exists t_many_partitions;
drop database fts;
